\section{Declaration}

A parser is declared as a Python object.

\section{Grammar rules}                                         \label{parser:grammar_rules}

Rule declarations have two parts.
The left side declares the symbol associated to the rule.
The right side describes the decomposition of the rule.
Both parts of the declaration are separated with an equal sign (\emph{$=$}).

See figure~\ref{parser:rule} for example.

\begin{code}
\caption{Rule declaration}                                      \label{parser:rule}
\begin{verbatimtab}[4]
    SYMBOL = (A & B) * (lambda a, b: f(a, b))
\end{verbatimtab}
\end{code}

\section{Sequences}                                             \label{parser:sequences}

Sequences in grammar rules describe in which order symbols should appear in the input string.
For example the sequence \emph{$A~\&~B$} recognizes an \emph{A} followed by a \emph{B}.

For example to say that a \emph{sum} is a \emph{term} \emph{plus} another \emph{term} you can write:
\begin{verbatimtab}[4]
    Sum = Term & '+' & Term
\end{verbatimtab}

\section{Alternatives}                                          \label{parser:alternatives}

Alternatives in grammar rules describe several possible decompositions of a symbol.
The infix pipe operator (\emph{$\mid$}) is used to separate alternatives.
\emph{$A~\mid~B$} recognizes either an \emph{A} or a \emph{B}.
If both \emph{A} and \emph{B} can be matched only the first match is considered.
So the order of alternatives is very important.
If an alternative has an empty choice, it must be the last.
Empty choices in other positions will be reported as syntax errors.

For example to say that an \emph{atom} is an \emph{integer} or an \emph{expression in paranthesis}
you can write:
\begin{verbatimtab}[4]
    Atom = integer | r'\(' & Expr & r'\)'
\end{verbatimtab}

\section{Repetitions}                                           \label{parser:repetitions}

Repetitions in grammar rules describe how many times an expression should be matched.

\begin{description}
    \item [{A[:1]}] recognizes zero or one \emph{A}.
    \item [{A[:]}] recognizes zero or more \emph{A}.
    \item [{A[1:]}] recognizes one or more \emph{A}.
    \item [{A[m:n]}] recognizes at least m and at most n \emph{A}.
\end{description}

Repetitions are greedy.
Repetitions are implemented as Python loops.
Thus whatever the length of the repetitions, the Python stack will not overflow. 

\section{Precedence and grouping}

The figure~\ref{parser:precedence} lists the different structures in increasing precedence order.
To override the default precedence you can group expressions with parenthesis.

\begin{tableau}
\caption{Precedence in SP expressions}                         \label{parser:precedence}
\begin{tabular}{| l | l |}
\hline
    Structure           & Example \\
\hline
\hline
    Alternative         & $A~\mid~B$ \\
\hline
    Sequence            & $A~\&~B$ \\
\hline
    Repetitions         & $A[x:y]$ \\
\hline
    Symbol and grouping & $A$ and $(~\ldots~)$ \\
\hline
\end{tabular}
\end{tableau}

\section{Actions}

Grammar rules can contain actions as Python functions.

Functions are applyied to parsed objects using $/$ or $*$.

$parser / function$ returns $function(result~of~parser)$.

$parser * function$ returns $function(*result~of~parser)$.

$*$ can be used to analyse the result of a sequence.

\subsection{Abstract syntax trees}                              \label{parser:AST}

An abstract syntax tree (AST) is an abstract representation of the structure of the input.
A node of an AST is a Python object (there is no constraint about its class).
AST nodes are completely defined by the user.

The figure~\ref{parser:ASTinst} shows a node symbolizing a couple.

\begin{code}
\caption{AST example}                                           \label{parser:ASTinst}
\begin{verbatimtab}[4]

class Couple:
    def __init__(self, a, b):
        self.a = a
        self.b = b

def Foo():
    couple = (Drop(r'\(') & item & Drop(',') & item & Drop(r'\)')) * Couple
    return couple
\end{verbatimtab}
\end{code}

