% This file is part of Simple Parser.
%
% Simple Parser is free software: you can redistribute it and/or modify
% it under the terms of the GNU Lesser General Public License as published
% by the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% Simple Parser is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU Lesser General Public License for more details.
%
% You should have received a copy of the GNU Lesser General Public License
% along with Simple Parser.  If not, see <http://www.gnu.org/licenses/>.

\section{Introduction}

This short tutorial presents how to make a simple calculator.
The calculator will compute basic mathematical expressions (\verb|+, -, *, /|) possibly nested in parenthesis.
We assume the reader is familiar with regular expressions.

\section{Defining the grammar}

Expressions are defined with a grammar.
For example an expression is a sum of terms and a term is a product of factors. A factor is either a number or a complete expression in parenthesis.

We describe such grammars with rules. A rule describe the composition of an item of the language. In our grammar we have 3 items (expr, term, factor). We will call these items `symbols' or `non terminal symbols'. The decomposition of a symbol is symbolized with $\to$.
The grammar of this tutorial is given in figure~\ref{tut:gramsymb_calc}.

\begin{tableau}
\caption{Grammar for expressions}                           \label{tut:gramsymb_calc}
\begin{tabular}{| l | p{7cm} |}
\hline
    Grammar rule & Description \\
\hline
\hline
    $expr~\to~term~(('+'|'-')~term)*$
        & An expression is a term eventually followed with a plus ($'+'$) or a minus ($'-'$) sign and an other term any number of times ($*$ is a repetition of an expression 0 or more times). \\
\hline
    $term~\to~fact~(('*'|'/')~fact)*$
        & A term is a factor eventually followed with a $'*'$ or $'/'$ sign and an other factor any number of times. \\
\hline
    $Fact~\to~('+'|'-')~fact|~number~|~'('~Expr~')'$
        & A factor is either a factor precedeed by a sign, a number or an expression in parenthesis. \\
\hline
\end{tabular}
\end{tableau}

We have defined here the grammar rules (i.e. the sentences of the language). We now need to describe the lexical items (i.e. the words of the language). These words - also called \emph{terminal symbols} - are described using regular expressions. In the rules we have written some of these terminal symbols ($+, -, *, /, (, )$). We have to define \emph{number}. For sake of simplicity numbers are integers composed of digits (the corresponding regular expression can be $[0-9]+$).
To simplify the grammar and then the Python script we define two terminal symbols to group the operators (additive and multiplicative operators). We can also define a special symbol that is ignored by SP. This symbol is used as a separator. This is generaly usefull for white spaces and comments. The terminal symbols are given in figure~\ref{tut:token_calc}

\begin{tableau}
\caption{Terminal symbol definition for expressions}        \label{tut:token_calc}
\begin{tabular}{| l | l | l |}
\hline
    Terminal symbol & Regular expression & Comment \\
\hline
\hline
    number & $[0-9]+$ or $\backslash d+$ & One or more digits \\
\hline
    addop & $[+-]$ & a $+$ or a $-$ \\
\hline
    mulop & $[*/]$ & a $*$ or a $/$ \\
\hline
    spaces & $\backslash s+$ & One or more spaces \\
\hline
\end{tabular}
\end{tableau}

This is sufficient to define our parser with SP. The grammar of the expressions in SP can be found in figure~\ref{tut:recognizer}.

\begin{code}
\caption{Grammar of the expression recognizer}              \label{tut:recognizer}
\begin{verbatimtab}[4]
def Calc():

    number = R(r'[0-9]+')
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= addop & fact
        fact |= '(' & expr & ')'
        fact |= number
        term = fact & ( mulop & fact )[:]
        expr |= term & ( addop & term )[:]

    return expr

\end{verbatimtab}
\end{code}

\emph{Calc} is the name of the Python function that returns a parser. This function returns \emph{expr} which is the \emph{axiom}\footnote{The axiom is the symbol from which the parsing starts} of the grammar.

\emph{expr} and \emph{fact} are recursive rules. They are first declared as empty rules ($expr~=~Rule()$) and alternatives are later added ($expr~|=~...$).

Slices are used to implement repetitions. $foo[:]$ parses $foo$ zero or more times, which is equivalent to $foo*$ is a classical grammar notation.

With this small grammar we can only recognize a correct expression. We will see in the next sections how to read the actual expression and to compute its value.

\section{Reading the input and returning values}

The input of the grammar is a string. To do something useful we need to read this string in order to transform it into an expected result.

This string can be read by catching the return value of terminal symbols. By default any terminal symbol returns a string containing the current token. So the token $'('$ always returns the string $'('$. For some tokens it may be useful to compute a Python object from the token. For example \emph{number} should return an integer instead of a string, \emph{addop} and \emph{mulop}, followed by a number, should return a function corresponding to the operator. That's why we will add a function to the token and rule definitions. So we associate \emph{int} to \emph{number} and \emph{op1} and \emph{op2} to unary and binary operators.

\emph{int} is a Python function converting objects to integers and \emph{op1} and \emph{op2} are user defined functions (figure~\ref{tut:make_op}).

\begin{code}
\caption{\emph{op1} and \emph{op2} functions}                          \label{tut:make_op}
\begin{verbatimtab}[4]
    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    # red applyies functions to a number
    def red(x, fs):
        for f in fs: x = f(x)
        return x
\end{verbatimtab}
\end{code}

To associate a function to a token or a rule it must be applyed using \emph{/} or \emph{*} operators as in figure~\ref{tut:tokens}
\emph{/} applyies a function to an object returned by a (sub)parser.
\emph{*} applyies a function to an tuple of objects returned by a sequence of (sub) parsers.

\begin{code}
\caption{Token and rule definitions with functions}                  \label{tut:tokens}
\begin{verbatimtab}[4]
    number = R(r'[0-9]+') / int

    fact |= (addop & fact) * op1
    term = (fact & ( (mulop & fact) * op2 )[:]) * red

    # R(r'[0-9]+') applyed on "42" will return "42".
    # R(r'[0-9]+') / int will return int("42")

    # addop & fact applyied on "+ 42" will return ('+', 42)
    # (addop & fact) * op1 will return op1(*('+', 42)), i.e. op1('+', 42)
    # so (addop & fact) * op1 returns +42

    # (addop & fact) * op2 will return op2(*('+', 42)), i.e. op2('+', 42)
    # so (addop & fact) * op2 returns lambda x: add(x, 42)

    # fact & ( (mulop & fact) * op2 )[:] returns a number and a list of functions
    # for instance (42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
    # so (fact & ( (mulop & fact) * op2 )[:]) * red applyied on "42*43*44"
    # will return red(42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
    # i.e. 42*43*44
\end{verbatimtab}
\end{code}

Finally the complete parser is given in figure~\ref{tut:parser}.

\begin{code}
\caption{Expression recognizer and evaluator}               \label{tut:parser}
\begin{verbatimtab}[4]
from sp import *

def Calc():

    from operator import pos, neg, add, sub, mul, truediv as div

    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    def red(x, fs):
        for f in fs: x = f(x)
        return x

    number = R(r'[0-9]+') / int
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= (addop & fact) * op1
        fact |= '(' & expr & ')'
        fact |= number
        term = (fact & ( (mulop & fact) * op2 )[:]) * red
        expr |= (term & ( (addop & term) * op2 )[:]) * red

    return expr
\end{verbatimtab}
\end{code}

\section{Embeding the parser in a script}

A parser is a simple Python object. This example show how to write a function that returns a parser. The parser can be applyied to strings just by calling the parser (see figure~\ref{tut:build_scheme}).

\begin{code}
\caption{Writting SP grammars in Python}             \label{tut:build_scheme}
\begin{verbatimtab}[4]
from sp import *

def MyParser():

    parser = ...

    return parser

# You can instanciate your parser here
my_parser = MyParser()

# and use it
parsed_object = my_parser(string_to_be_parsed)
\end{verbatimtab}
\end{code}

To use this parser you now just need to instanciate an object as in figure~\ref{tut:calc}.

\begin{code}
\caption{Complete Python script with expression parser}     \label{tut:calc}
\begin{verbatimtab}[4]
from sp import *

def Calc():

    from operator import pos, neg, add, sub, mul, truediv as div

    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    def red(x, fs):
        for f in fs: x = f(x)
        return x

    number = R(r'[0-9]+') / int
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= (addop & fact) * op1
        fact |= '(' & expr & ')'
        fact |= number
        term = (fact & ( (mulop & fact) * op2 )[:]) * red
        expr |= (term & ( (addop & term) * op2 )[:]) * red

    return expr

calc = Calc()
while True:
    expr = input('Enter an expression: ')
    try: print(expr, '=', calc(expr))
    except Exception as e: print("%s:"%e.__class__.__name__, e)
\end{verbatimtab}
\end{code}

\clearpage

\section{Conclusion}

This tutorial shows some of the possibilities of SP.
If you have read it carefully you may be able to start with SP.
The next chapters present SP more precisely.
They contain more examples to illustrate all the features of SP.

Happy SP'ing!
