<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Simple Parser</title>
<meta name="author" content="Christophe Delord" />
<meta name="date" content="Friday 24 July 2009" />
<style type="text/css">

/*
Author: Frederic Culot
Date: 2008-05-28
Copyright: This stylesheet has been placed in the public domain - free to edit and use for all uses.
*/
/*
Modified by C. Delord for Simple Parser
- some margins and paddings removed
*/

body {
  font: 100% sans-serif;
  color: black;
  /*padding: 0em 2em;*/
}

@media screen {
  body {
    background: #003a6b;
    /*margin: 2em;*/
  }
  .document, div.footer {
    border: 1px solid gray;
    margin: 0 auto;
    width: /*90%;*/ 95%;
    background-color: #ffffff;
    padding: 1.5em;
  }
}

@media print {
  body {
    background: #ffffff;
    border: 2px solid #003a6b;
    margin: 0em;
  }
}

div.footer {
  text-align: right;
}

p.topic-title {
  font-weight: bold;
}

table.docinfo {
  text-align: left;
  margin: 2em 0em;
}

a[href] {
  color: #436976;
  background-color: transparent;
}

a.toc-backref {
  text-decoration: none;
}

h1 a[href] {
  color: #003a6b;
  text-decoration: none;
  background-color: transparent;
}

a.strong {
  font-weight: bold;
}

img {
  margin: 0;
  border: 0;
}

p {
  margin: 0.5em 0 1em 0;
  line-height: 1.5em;
}

p a:visited {
  color: purple;
  background-color: transparent;
}

p a:active {
  color: red;
  background-color: transparent;
}

a:hover {
  text-decoration: none;
}

p img {
  border: 0;
  margin: 0;
}

p.rubric {
  font-weight: bold;
  font-style: italic;
}

h1.title {
  color: #003a6b;
  font-size: 250%;
  margin-bottom: 0em;
}

h2.subtitle {
  color: #003a6b;
  border-bottom: 0px;
}

h1, h2, h3, h4, h5, h6 {
  color: #555;
  background-color: transparent;
  margin: 0em;
  padding-top: 0.5em;
}

h1 {
  font-size: 160%;
  margin-bottom: 0.5em;
  border-bottom: 2px solid #aaa;
}

h2 {
  font-size: 140%;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #aaa;
}

h3 {
  font-size: 130%;
  margin-bottom: 0.5em;
}

h4 {
  font-size: 110%;
  font-weight: bold;
  margin-bottom: 0.5em;
}

h5 {
  font-size: 105%;
  font-weight: bold;
  margin-bottom: 0.5em;
}

h6 {
  font-size: 100%;
  font-weight: bold;
  margin-bottom: 0.5em;
}

dt {
  font-style: italic;
}

dd {
  margin-bottom: 1.5em;
}

div.admonition, div.note, div.tip, div.caution, div.important {
  margin: 2em 2em;
  padding: 0em 1em;
  border-top: 1px solid #aaa;
  border-left: 1px solid #aaa;
  border-bottom: 2px solid #555;
  border-right: 2px solid #555;
}

div.important {
  background: transparent url('../images/important.png') 10px 2px no-repeat;
}

div.caution {
  background: transparent url('../images/caution.png') 10px 2px no-repeat;
}

div.note {
  background: transparent url('../images/note.png') 10px 2px no-repeat;
}

div.tip {
  background: transparent url('../images/tip.png') 10px 2px no-repeat;
}

div.admonition-example {
  background: transparent url('../images/tip.png') 10px 2px no-repeat;
}

div.admonition-critical-example {
  background: transparent url('../images/important.png') 10px 2px no-repeat;
}

p.admonition-title {
  font-weight: bold;
  border-bottom: 1px solid #aaa;
  padding-left: 30px;
}

table.docutils {
  text-align: left;
  border-left: 1px solid gray;
  border-collapse: collapse;
  width: 100%;
  margin: 0em 0em;
}

table.docutils caption {
  font-style: italic;
}

table.docutils td, table.docutils th {
  padding: 0.25em 0.5em;
}

table.docutils th {
  background-color: #dddddd;
}

div.sidebar {
  width: 33%;
  float: right;
  margin: 0em 2em;
  padding: 0em 1em;
  border-top: 1px solid #aaa;
  border-left: 1px solid #aaa;
  border-bottom: 2px solid #555;
  border-right: 2px solid #555;
}

p.sidebar-title {
  margin-bottom: 0em;
  color: #003a6b;
  border-bottom: 1px solid #aaa;
  font-weight: bold;
}

p.sidebar-subtitle {
  margin-top: 0em;
  font-style: italic;
  color: #003a6b;
}

pre, .pre {
  font-family: monospace;
  font-size: 1.1em;
  color: #444499;
}

pre.literal-block, pre.doctest-block {
  border: 1px solid gray;
  padding: 5px;
  background-color: #dddddd;
  margin: 0 5em 0 5em ;
}

</style>
</head>
<body>
<div class="document" id="simple-parser">
<h1 class="title">Simple Parser</h1>
<h2 class="subtitle" id="how-to-easily-write-parsers-in-python">How to easily write parsers in Python</h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Christophe Delord</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference external" href="mailto:christophe&#46;delord&#37;&#52;&#48;free&#46;fr">christophe<span>&#46;</span>delord<span>&#64;</span>free<span>&#46;</span>fr</a></td></tr>
<tr class="field"><th class="docinfo-name">Web site:</th><td class="field-body"><a class="reference external" href="http://christophe.delord.free.fr/sp">http://christophe.delord.free.fr/sp</a></td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>Friday 24 July 2009</td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">This software is released under the LGPL license.</td>
</tr>
</tbody>
</table>
<!-- This file is part of Simple Parser. -->
<!-- Simple Parser is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. -->
<!-- Simple Parser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details. -->
<!-- You should have received a copy of the GNU Lesser General Public License
along with Simple Parser.  If not, see <http://www.gnu.org/licenses/>. -->
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction-and-tutorial" id="id10">1&nbsp;&nbsp;&nbsp;Introduction and tutorial</a><ul class="auto-toc">
<li><a class="reference internal" href="#introduction" id="id11">1.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#installation" id="id12">1.2&nbsp;&nbsp;&nbsp;Installation</a></li>
<li><a class="reference internal" href="#tutorial" id="id13">1.3&nbsp;&nbsp;&nbsp;Tutorial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sp-reference" id="id14">2&nbsp;&nbsp;&nbsp;SP reference</a><ul class="auto-toc">
<li><a class="reference internal" href="#usage" id="id15">2.1&nbsp;&nbsp;&nbsp;Usage</a></li>
<li><a class="reference internal" href="#grammar-structure" id="id16">2.2&nbsp;&nbsp;&nbsp;Grammar structure</a></li>
<li><a class="reference internal" href="#lexer" id="id17">2.3&nbsp;&nbsp;&nbsp;Lexer</a></li>
<li><a class="reference internal" href="#parser" id="id18">2.4&nbsp;&nbsp;&nbsp;Parser</a></li>
</ul>
</li>
<li><a class="reference internal" href="#some-examples-to-illustrate-sp" id="id19">3&nbsp;&nbsp;&nbsp;Some examples to illustrate SP</a><ul class="auto-toc">
<li><a class="reference internal" href="#complete-interactive-calculator" id="id20">3.1&nbsp;&nbsp;&nbsp;Complete interactive calculator</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction-and-tutorial">
<h1><a class="toc-backref" href="#id10">1&nbsp;&nbsp;&nbsp;Introduction and tutorial</a></h1>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id11">1.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>SP (Simple Parser) is a Python <a class="footnote-reference" href="#id2" id="id1">[1]</a> parser generator.
It is aimed at easy usage rather than performance.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Python is a wonderful object oriented programming language available at <a class="reference external" href="http://www.python.org">http://www.python.org</a></td></tr>
</tbody>
</table>
<div class="section" id="license">
<h3>License</h3>
<p>SP is available under the GNU Lesser General Public:</p>
<pre class="literal-block">
Simple Parser: A Python parser generator

Copyright (C) 2009 Christophe Delord

Simple Parser is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Simple Parser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Simple Parser.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</pre>
</div>
<div class="section" id="structure-of-the-document">
<h3>Structure of the document</h3>
<dl class="docutils">
<dt><a class="reference internal" href="#introduction-and-tutorial">Introduction and tutorial</a></dt>
<dd>starts smoothly with a gentle tutorial as an introduction.
I think this tutorial may be sufficent to start with SP.</dd>
<dt><a class="reference internal" href="#sp-reference">SP reference</a></dt>
<dd>is a reference documentation. It will detail SP as much as possible.</dd>
<dt><a class="reference internal" href="#some-examples-to-illustrate-sp">Some examples to illustrate SP</a></dt>
<dd>gives the reader some examples to illustrate SP.</dd>
</dl>
</div>
</div>
<div class="section" id="installation">
<h2><a class="toc-backref" href="#id12">1.2&nbsp;&nbsp;&nbsp;Installation</a></h2>
<div class="section" id="getting-sp">
<h3>Getting SP</h3>
<p>SP is freely available on its web page (<a class="reference external" href="http://christophe.delord.free.fr/sp">http://christophe.delord.free.fr/sp</a>).</p>
</div>
<div class="section" id="requirements">
<h3>Requirements</h3>
<p>SP is a <em>pure Python</em> package.
It may run on <em>any platform</em> supported by Python.
The only requirement of SP is <em>Python 3.0</em> or newer.
Python can be downloaded at <a class="reference external" href="http://www.python.org">http://www.python.org</a>.</p>
</div>
</div>
<div class="section" id="tutorial">
<h2><a class="toc-backref" href="#id13">1.3&nbsp;&nbsp;&nbsp;Tutorial</a></h2>
<div class="section" id="id3">
<h3>Introduction</h3>
<p>This short tutorial presents how to make a simple calculator.
The calculator will compute basic mathematical expressions (<tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">|</span></tt>) possibly nested in parenthesis.
We assume the reader is familiar with regular expressions.</p>
</div>
<div class="section" id="defining-the-grammar">
<h3>Defining the grammar</h3>
<p>Expressions are defined with a grammar.
For example an expression is a sum of terms and a term is a product of factors.
A factor is either a number or a complete expression in parenthesis.</p>
<p>We describe such grammars with rules.
A rule describes the composition of an item of the language.
In our grammar we have 3 items (expr, term, factor).
We will call these items <em>symbols</em> or <em>non terminal symbols</em>.
The decomposition of a symbol is symbolized with <tt class="docutils literal"><span class="pre">-&gt;</span></tt>.</p>
<p>Grammar for expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Grammar rule</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">expr</span> <span class="pre">-&gt;</span> <span class="pre">term</span> <span class="pre">(('+'|'-')</span> <span class="pre">term)*</span></tt></td>
<td>An expression is a term eventually followed
with a plus (<tt class="docutils literal"><span class="pre">+</span></tt>) or a minus (<tt class="docutils literal"><span class="pre">-</span></tt>) sign
and an other term any number of times
(<tt class="docutils literal"><span class="pre">*</span></tt> is a repetition of an expression 0 or more times).</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">term</span> <span class="pre">-&gt;</span> <span class="pre">fact</span> <span class="pre">(('*'|'/')</span> <span class="pre">fact)*</span></tt></td>
<td>A term is a factor eventually followed
with a <tt class="docutils literal"><span class="pre">*</span></tt> or <tt class="docutils literal"><span class="pre">/</span></tt> sign
and an other factor any number of times.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">fact</span> <span class="pre">-&gt;</span> <span class="pre">('+'|'-')</span> <span class="pre">fact</span> <span class="pre">|</span> <span class="pre">number</span> <span class="pre">|</span> <span class="pre">'('</span> <span class="pre">expr</span> <span class="pre">')'</span></tt></td>
<td>A factor is either a factor precedeed by a sign, a number
or an expression in parenthesis.</td>
</tr>
</tbody>
</table>
<p>We have defined here the grammar rules (i.e. the sentences of the language).
We now need to describe the lexical items (i.e. the words of the language).
These words - also called <em>terminal symbols</em> - are described using regular expressions.
In the rules we have written some of these terminal symbols (<tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt>, <tt class="docutils literal"><span class="pre">(</span></tt>, <tt class="docutils literal"><span class="pre">)</span></tt>).
We have to define <tt class="docutils literal"><span class="pre">number</span></tt>.
For sake of simplicity numbers are integers composed of digits (the corresponding regular expression can be <tt class="docutils literal"><span class="pre">[0-9]+</span></tt>).
To simplify the grammar and then the Python script we define two terminal symbols to group the operators (additive and multiplicative operators).
We can also define a special symbol that is ignored by SP.
This symbol is used as a separator.
This is generaly usefull for white spaces and comments.</p>
<p>Terminal symbol definition for expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="37%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Terminal symbol</th>
<th class="head">Regular expression</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">number</span></tt></td>
<td><tt class="docutils literal"><span class="pre">[0-9]+</span> <span class="pre">or</span> <span class="pre">\d+</span></tt></td>
<td>One or more digits</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">addop</span></tt></td>
<td><tt class="docutils literal"><span class="pre">[+-]</span></tt></td>
<td>a <tt class="docutils literal"><span class="pre">+</span></tt> or a <tt class="docutils literal"><span class="pre">-</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">mulop</span></tt></td>
<td><tt class="docutils literal"><span class="pre">[*/]</span></tt></td>
<td>a <tt class="docutils literal"><span class="pre">*</span></tt> or a <tt class="docutils literal"><span class="pre">/</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">spaces</span></tt></td>
<td><tt class="docutils literal"><span class="pre">\s+</span></tt></td>
<td>One or more spaces</td>
</tr>
</tbody>
</table>
<p>This is sufficient to define our parser with SP.</p>
<p>Grammar of the expression recognizer:</p>
<pre class="literal-block">
def Calc():

    number = R(r'[0-9]+')
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= addop &amp; fact
        fact |= '(' &amp; expr &amp; ')'
        fact |= number
        term = fact &amp; ( mulop &amp; fact )[:]
        expr |= term &amp; ( addop &amp; term )[:]

    return expr
</pre>
<p><tt class="docutils literal"><span class="pre">Calc</span></tt> is the name of the Python function that returns a parser.
This function returns <tt class="docutils literal"><span class="pre">expr</span></tt> which is the <em>axiom</em> <a class="footnote-reference" href="#id5" id="id4">[2]</a> of the grammer.</p>
<p><tt class="docutils literal"><span class="pre">expr</span></tt> and <tt class="docutils literal"><span class="pre">fact</span></tt> are recursive rules.
They are first declared as empty rules (<tt class="docutils literal"><span class="pre">expr</span> <span class="pre">=</span> <span class="pre">Rule()</span></tt>) and alternatives are later added (<tt class="docutils literal"><span class="pre">expr</span> <span class="pre">|=</span> <span class="pre">...</span></tt>).</p>
<p>Slices are used to implement repetitions.
<tt class="docutils literal"><span class="pre">foo[:]</span></tt> parses <tt class="docutils literal"><span class="pre">foo</span></tt> zero or more times, which is equivalent to <tt class="docutils literal"><span class="pre">foo*</span></tt> is a classical grammar notation.</p>
<p>With this small grammar we can only recognize a correct expression.
We will see in the next sections how to read the actual expression and to compute its value.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>The axiom is the symbol from which the parsing starts</td></tr>
</tbody>
</table>
</div>
<div class="section" id="reading-the-input-and-returning-values">
<h3>Reading the input and returning values</h3>
<p>The input of the grammar is a string.
To do something useful we need to read this string in order to transform it into an expected result.</p>
<p>This string can be read by catching the return value of terminal symbols.
By default any terminal symbol returns a string containing the current token.
So the token <tt class="docutils literal"><span class="pre">'('</span></tt> always returns the string <tt class="docutils literal"><span class="pre">'('</span></tt>.
For some tokens it may be useful to compute a Python object from the token.
For example <tt class="docutils literal"><span class="pre">number</span></tt> should return an integer instead of a string,
<tt class="docutils literal"><span class="pre">addop</span></tt> and <tt class="docutils literal"><span class="pre">mulop</span></tt>, followed by a number, should return a function corresponding to the operator.
That's why we will add a function to the token and rule definitions.
So we associate <tt class="docutils literal"><span class="pre">int</span></tt> to <tt class="docutils literal"><span class="pre">number</span></tt> and <tt class="docutils literal"><span class="pre">op1</span></tt> and <tt class="docutils literal"><span class="pre">op2</span></tt> to unary and binary operators.</p>
<p><tt class="docutils literal"><span class="pre">int</span></tt> is a Python function converting objects to integers and <tt class="docutils literal"><span class="pre">op1</span></tt> and <tt class="docutils literal"><span class="pre">op2</span></tt> are user defined functions.</p>
<p><tt class="docutils literal"><span class="pre">op1</span></tt> and <tt class="docutils literal"><span class="pre">op2</span></tt> functions:</p>
<pre class="literal-block">
op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

# red applyies functions to a number
def red(x, fs):
    for f in fs: x = f(x)
    return x
</pre>
<dl class="docutils">
<dt>To associate a function to a token or a rule it must be applyed using <tt class="docutils literal"><span class="pre">/</span></tt> or <tt class="docutils literal"><span class="pre">*</span></tt> operators:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">/</span></tt> applyies a function to an object returned by a (sub)parser.</li>
<li><tt class="docutils literal"><span class="pre">*</span></tt> applyies a function to an tuple of objects returned by a sequence of (sub) parsers.</li>
</ul>
</dd>
</dl>
<p>Token and rule definitions with functions:</p>
<pre class="literal-block">
number = R(r'[0-9]+') / int

fact |= (addop &amp; fact) * op1
term = (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red

# R(r'[0-9]+') applyed on &quot;42&quot; will return &quot;42&quot;.
# R(r'[0-9]+') / int will return int(&quot;42&quot;)

# addop &amp; fact applyied on &quot;+ 42&quot; will return ('+', 42)
# (addop &amp; fact) * op1 will return op1(*('+', 42)), i.e. op1('+', 42)
# so (addop &amp; fact) * op1 returns +42

# (addop &amp; fact) * op2 will return op2(*('+', 42)), i.e. op2('+', 42)
# so (addop &amp; fact) * op2 returns lambda x: add(x, 42)

# fact &amp; ( (mulop &amp; fact) * op2 )[:] returns a number and a list of functions
# for instance (42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
# so (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red applyied on &quot;42*43*44&quot;
# will return red(42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
# i.e. 42*43*44
</pre>
<p>Here is finally the complete parser.</p>
<p>Expression recognizer and evaluator:</p>
<pre class="literal-block">
from sp import *

def Calc():

    from operator import pos, neg, add, sub, mul, truediv as div

    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    def red(x, fs):
        for f in fs: x = f(x)
        return x

    number = R(r'[0-9]+') / int
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= (addop &amp; fact) * op1
        fact |= '(' &amp; expr &amp; ')'
        fact |= number
        term = (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red
        expr |= (term &amp; ( (addop &amp; term) * op2 )[:]) * red

    return expr
</pre>
</div>
<div class="section" id="embeding-the-parser-in-a-script">
<h3>Embeding the parser in a script</h3>
<p>A parser is a simple Python object.
This example show how to write a function that returns a parser.
The parser can be applyied to strings by simply calling the parser.</p>
<p>Writting SP grammars in Python:</p>
<pre class="literal-block">
from sp import *

def MyParser():

    parser = ...

    return parser

# You can instanciate your parser here
my_parser = MyParser()

# and use it
parsed_object = my_parser(string_to_be_parsed)
</pre>
<p>To use this parser you now just need to instanciate an object.</p>
<p>Complete Python script with expression parser:</p>
<pre class="literal-block">
from sp import *

def Calc():

    from operator import pos, neg, add, sub, mul, truediv as div

    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    def red(x, fs):
        for f in fs: x = f(x)
        return x

    number = R(r'[0-9]+') / int
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= (addop &amp; fact) * op1
        fact |= '(' &amp; expr &amp; ')'
        fact |= number
        term = (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red
        expr |= (term &amp; ( (addop &amp; term) * op2 )[:]) * red

    return expr

calc = Calc()
while True:
    expr = input('Enter an expression: ')
    try: print(expr, '=', calc(expr))
    except Exception as e: print(&quot;%s:&quot;%e.__class__.__name__, e)
</pre>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>This tutorial shows some of the possibilities of SP.
If you have read it carefully you may be able to start with SP.
The next chapters present SP more precisely.
They contain more examples to illustrate all the features of SP.</p>
<p>Happy SP'ing!</p>
</div>
</div>
</div>
<div class="section" id="sp-reference">
<h1><a class="toc-backref" href="#id14">2&nbsp;&nbsp;&nbsp;SP reference</a></h1>
<div class="section" id="usage">
<h2><a class="toc-backref" href="#id15">2.1&nbsp;&nbsp;&nbsp;Usage</a></h2>
<p>SP is a package which main function is to provide basic objects to build a complete parser.</p>
<p>The grammar is a Python object.</p>
<p>Grammar embeding example:</p>
<pre class="literal-block">
def Foo():
    bar = R('bar')
    return bar
</pre>
<p>Then you can use the new generated parser.
The parser is simply a Python object.</p>
<p>Parser usage example:</p>
<pre class="literal-block">
test = &quot;bar&quot;
my_parser = Foo()
x = my_parser(test)               # Parses &quot;bar&quot;
print x
</pre>
</div>
<div class="section" id="grammar-structure">
<h2><a class="toc-backref" href="#id16">2.2&nbsp;&nbsp;&nbsp;Grammar structure</a></h2>
<p>SP grammars are Python objects.
SP grammars may contain two parts:</p>
<dl class="docutils">
<dt>Tokens</dt>
<dd>are built by the <tt class="docutils literal"><span class="pre">R</span></tt> or <tt class="docutils literal"><span class="pre">K</span></tt> keywords.</dd>
<dt>Rules</dt>
<dd>are described after tokens in a <tt class="docutils literal"><span class="pre">Separator</span></tt> context.</dd>
</dl>
<p>Example of SP grammar structure:</p>
<pre class="literal-block">
def Foo():

    # Tokens
    number = R(r'\d+') / int

    # Rules
    with Separator(r'\s+'):
        S = number[:]

    return S

foo = Foo()
result = foo(&quot;42 43 44&quot;) # return [42, 43, 44]
</pre>
</div>
<div class="section" id="lexer">
<h2><a class="toc-backref" href="#id17">2.3&nbsp;&nbsp;&nbsp;Lexer</a></h2>
<div class="section" id="regular-expression-syntax">
<h3>Regular expression syntax</h3>
<p>The lexer is based on the <em>re</em> <a class="footnote-reference" href="#id8" id="id6">[3]</a> module.
SP profits from the power of Python regular expressions.
This document assumes the reader is familiar with regular expressions.</p>
<p>You can use the syntax of regular expressions as expected by the <em>re</em> <a class="footnote-reference" href="#id9" id="id7">[4]</a> module.</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[3]</a></td><td><em>re</em> is a standard Python module.
It handles regular expressions.
For further information about <em>re</em> you can read <a class="reference external" href="http://docs.python.org/lib/module-re.html">http://docs.python.org/lib/module-re.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[4]</a></td><td>Read the Python documentation for further information: <a class="reference external" href="http://docs.python.org/lib/re-syntax.html">http://docs.python.org/lib/re-syntax.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="predefined-tokens">
<h3>Predefined tokens</h3>
<p>Tokens can be explicitely defined by the <tt class="docutils literal"><span class="pre">R</span></tt>, <tt class="docutils literal"><span class="pre">K</span></tt> and <tt class="docutils literal"><span class="pre">Separator</span></tt> keywords.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">R</span></tt></td>
<td>defines a regular token.
The token is defined with a regular expression and returns a string.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">K</span></tt></td>
<td>defines a token that returns nothing (usefull for keywords for instance).
The keyword is defined by an identifier (in this case word boundaries
are expected around the keyword) or another string (in this case the
pattern is not considered as a regular expression).
The token just recognizes a keyword and returns nothing.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">Separator</span></tt></td>
<td>if a context manager used to define separators for the rules defined
in the context.
The token is defined with a regular expression and returns nothing.</td>
</tr>
</tbody>
</table>
<p>A token can be defined by:</p>
<dl class="docutils">
<dt>a name</dt>
<dd>which identifies the token.
This name is used by the parser.</dd>
<dt>a regular expression</dt>
<dd>which describes what to match to recognize the token.</dd>
<dt>an action</dt>
<dd>which can translate the matched text into a Python object.
It can be a function of one argument or a non callable object.
If it is not callable, it will be returned for each token
otherwise it will be applied to the text of the token and the result will be returned.
This action is optional. By default the token text is returned.</dd>
</dl>
<p>Token definition examples:</p>
<pre class="literal-block">
integer = R(r'\d+') / int
identifier = R(r'[a-zA-Z]\w*\b')
boolean = R(r'(True|False)\b') / (lambda b: b=='True')

spaces = K(r'\s+')
comments = K(r'#.*')

with Separator(spaces|comments):
    # rules defined here will use spaces and comments as separators
    atom = '(' &amp; expr &amp; ')'
</pre>
<p>There are two kinds of tokens.
Tokens defined by the <tt class="docutils literal"><span class="pre">R</span></tt> or <tt class="docutils literal"><span class="pre">K</span></tt> keywords are parsed by the parser
and tokens defined by the <tt class="docutils literal"><span class="pre">Separator</span></tt> keyword are considered as separators
(white spaces or comments for example) and are wiped out by the lexer.</p>
<p>The word boundary <tt class="docutils literal"><span class="pre">\b</span></tt> can be used to avoid recognizing &quot;True&quot; at the beginning of &quot;Truexyz&quot;.</p>
</div>
<div class="section" id="inline-tokens">
<h3>Inline tokens</h3>
<p>Tokens can also be defined on the fly.
Their definition are then inlined in the grammar rules.
This feature may be useful for keywords or punctuation signs.</p>
<p>In this case tokens can be written without the <tt class="docutils literal"><span class="pre">R</span></tt> or <tt class="docutils literal"><span class="pre">K</span></tt> keywords.
They are considered as keywords (as defined by <tt class="docutils literal"><span class="pre">K</span></tt>).</p>
<p>Inline token definition examples:</p>
<pre class="literal-block">
IfThenElse = 'if' &amp; Cond &amp;
             'then' &amp; Statement &amp;
             'else' &amp; Statement
</pre>
</div>
</div>
<div class="section" id="parser">
<h2><a class="toc-backref" href="#id18">2.4&nbsp;&nbsp;&nbsp;Parser</a></h2>
<div class="section" id="declaration">
<h3>Declaration</h3>
<p>A parser is declared as a Python object.</p>
</div>
<div class="section" id="grammar-rules">
<h3>Grammar rules</h3>
<p>Rule declarations have two parts.
The left side declares the symbol associated to the rule.
The right side describes the decomposition of the rule.
Both parts of the declaration are separated with an equal sign (<tt class="docutils literal"><span class="pre">=</span></tt>).</p>
<p>Rule declaration example:</p>
<pre class="literal-block">
SYMBOL = (A &amp; B) * (lambda a, b: f(a, b))
</pre>
</div>
<div class="section" id="sequences">
<h3>Sequences</h3>
<p>Sequences in grammar rules describe in which order symbols should appear in the input string.
For example the sequence <tt class="docutils literal"><span class="pre">A</span> <span class="pre">&amp;</span> <span class="pre">B</span></tt> recognizes an <tt class="docutils literal"><span class="pre">A</span></tt> followed by a <tt class="docutils literal"><span class="pre">B</span></tt>.</p>
<p>For example to say that a <tt class="docutils literal"><span class="pre">sum</span></tt> is a <tt class="docutils literal"><span class="pre">term</span></tt> plus another <tt class="docutils literal"><span class="pre">term</span></tt> you can write:</p>
<pre class="literal-block">
Sum = Term &amp; '+' &amp; Term
</pre>
</div>
<div class="section" id="alternatives">
<h3>Alternatives</h3>
<p>Alternatives in grammar rules describe several possible decompositions of a symbol.
The infix pipe operator (<tt class="docutils literal"><span class="pre">|</span></tt>) is used to separate alternatives.
<tt class="docutils literal"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></tt> recognizes either an <tt class="docutils literal"><span class="pre">A</span></tt> or a <tt class="docutils literal"><span class="pre">B</span></tt>.
If both <tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">B</span></tt> can be matched only the first match is considered.
So the order of alternatives is very important.
If an alternative has an empty choice, it must be the last.
Empty choices in other positions will be reported as syntax errors.</p>
<p>For example to say that an <tt class="docutils literal"><span class="pre">atom</span></tt> is an <em>integer</em> or an <em>expression in paranthesis</em>
you can write:</p>
<pre class="literal-block">
Atom = integer | '(' &amp; Expr &amp; ')'
</pre>
</div>
<div class="section" id="repetitions">
<h3>Repetitions</h3>
<p>Repetitions in grammar rules describe how many times an expression should be matched.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">A[:1]</span></tt></td>
<td>recognizes zero or one <tt class="docutils literal"><span class="pre">A</span></tt>.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">A[:]</span></tt></td>
<td>recognizes zero or more <tt class="docutils literal"><span class="pre">A</span></tt>.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">A[1:]</span></tt></td>
<td>recognizes one or more <tt class="docutils literal"><span class="pre">A</span></tt>.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">A[m:n]</span></tt></td>
<td>recognizes at least m and at most n <tt class="docutils literal"><span class="pre">A</span></tt>.</td>
</tr>
</tbody>
</table>
<p>Repetitions are greedy.
Repetitions are implemented as Python loops.
Thus whatever the length of the repetitions, the Python stack will not overflow.</p>
</div>
<div class="section" id="precedence-and-grouping">
<h3>Precedence and grouping</h3>
<p>The following table lists the different structures in increasing precedence order.
To override the default precedence you can group expressions with parenthesis.</p>
<p>Precedence in SP expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Structure</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr><td rowspan="2">Alternative</td>
<td rowspan="2"><tt class="docutils literal"><span class="pre">A</span> <span class="pre">|</span> <span class="pre">B</span></tt></td>
</tr>
<tr></tr>
<tr><td rowspan="2">Sequence</td>
<td rowspan="2"><tt class="docutils literal"><span class="pre">A</span> <span class="pre">&amp;</span> <span class="pre">B</span></tt></td>
</tr>
<tr></tr>
<tr><td rowspan="2">Repetitions</td>
<td rowspan="2"><tt class="docutils literal"><span class="pre">A[x:y]</span></tt></td>
</tr>
<tr></tr>
<tr><td rowspan="2">Symbol and grouping</td>
<td rowspan="2"><tt class="docutils literal"><span class="pre">A</span></tt> and <tt class="docutils literal"><span class="pre">(</span> <span class="pre">...</span> <span class="pre">)</span></tt></td>
</tr>
<tr></tr>
</tbody>
</table>
</div>
<div class="section" id="actions">
<h3>Actions</h3>
<p>Grammar rules can contain actions as Python functions.</p>
<p>Functions are applyied to parsed objects using <tt class="docutils literal"><span class="pre">/</span></tt> or <tt class="docutils literal"><span class="pre">*</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">parser</span> <span class="pre">/</span> <span class="pre">function</span></tt></td>
<td>returns <em>function(result of parser)</em>.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">parser</span> <span class="pre">*</span> <span class="pre">function</span></tt></td>
<td>returns <em>function(*result of parser)</em>.</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">*</span></tt> can be used to analyse the result of a sequence.</p>
</div>
<div class="section" id="abstract-syntax-trees">
<h3>Abstract syntax trees</h3>
<p>An abstract syntax tree (AST) is an abstract representation of the structure of the input.
A node of an AST is a Python object (there is no constraint about its class).
AST nodes are completely defined by the user.</p>
<p>AST example (parsing a couple):</p>
<pre class="literal-block">
class Couple:
    def __init__(self, a, b):
        self.a = a
        self.b = b

def Foo():
    couple = ('(' &amp; item &amp; ',' &amp; item &amp; ')') * Couple
    return couple
</pre>
</div>
</div>
</div>
<div class="section" id="some-examples-to-illustrate-sp">
<h1><a class="toc-backref" href="#id19">3&nbsp;&nbsp;&nbsp;Some examples to illustrate SP</a></h1>
<div class="section" id="complete-interactive-calculator">
<h2><a class="toc-backref" href="#id20">3.1&nbsp;&nbsp;&nbsp;Complete interactive calculator</a></h2>
<p>This chapter presents an extention of the calculator described in the tutorial (see~ref{sp:tutorial}).
This calculator has more functions and a memory.</p>
<div class="section" id="new-functions">
<h3>New functions</h3>
<p>The calculator has memories.
A memory cell is identified by a name.
For example, if the user types <tt class="docutils literal"><span class="pre">pi</span> <span class="pre">=</span> <span class="pre">3.14</span></tt>},
the memory cell named <tt class="docutils literal"><span class="pre">pi</span></tt> will contain the value of <tt class="docutils literal"><span class="pre">pi</span></tt>
and <tt class="docutils literal"><span class="pre">2*pi</span></tt> will return <tt class="docutils literal"><span class="pre">6.28</span></tt>.</p>
<p>The variables are saved in a dictionnary.</p>
<p>Source code</p>
<p>Here is the complete source code (<em>calc.py</em>):</p>
<pre class="literal-block">
#!/usr/bin/env python3

# This file is part of Simple Parser.
# 
# Simple Parser is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Simple Parser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with Simple Parser.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

&quot;&quot;&quot; Calc

num  : generic numerical calculus   | assignment: name = expression
int  : integral calculus            | binary    : b... or ...b
int8 : integral calculus on 8 bits  | octal     : o... or ...o
int16: integral calculus on 16 bits | hexa      : h... or ...h or 0x...
int32: integral calculus on 32 bits | operators : + - | ^ * % / &amp; &gt;&gt; &lt;&lt; ~ **
int64: integral calculus on 64 bits | functions : rev factor
flt32: 32 bit float calculus        |
flt64: 64 bit float calculus        |
rat  : rational calculus            | this help : ?
&quot;&quot;&quot;

import struct
import sys

from sp import *
from fractions import Fraction

try:
    import readline
except ImportError:
    pass

class Num:
    name, descr = &quot;num&quot;, &quot;Number&quot;
    def __init__(self, val):
        if isinstance(val, Num): self.val = val.val
        else: self.val = val
    def __int__(self):      return int(self.val)
    def __float__(self):    return float(self.val)
    def __str__(self):      return str(self.val)
    def __add__(x, y):      return x.__class__(x.val + y.val)
    def __sub__(x, y):      return x.__class__(x.val - y.val)
    def __or__(x, y):       return x.__class__(x.val | y.val)
    def __xor__(x, y):      return x.__class__(x.val ^ y.val)
    def __mul__(x, y):      return x.__class__(x.val * y.val)
    def __mod__(x, y):      return x.__class__(x.val % y.val)
    def __truediv__(x, y):  return x.__class__(x.val / y.val)
    def __and__(x, y):      return x.__class__(x.val &amp; y.val)
    def __rshift__(x, y):   return x.__class__(x.val &gt;&gt; y.val)
    def __lshift__(x, y):   return x.__class__(x.val &lt;&lt; y.val)
    def __pos__(x):         return x.__class__(+x.val)
    def __neg__(x):         return x.__class__(-x.val)
    def __invert__(x):      return x.__class__(~x.val)
    def __pow__(x, y):      return x.__class__(x.val ** y.val)
    def rev(self):
        raise TypeError(&quot;%s can not be bit reversed&quot;%self.__class__.__name__)
    def factor(self):
        n = int(self.val)
        if n != self.val: raise TypeError(&quot;%s is not integer&quot;%self.val)
        if n &lt; 0: ds = [-1]; n = -n
        else: ds = []
        rn = n**0.5
        while n &gt; 1 and n%2==0: ds.append(2); n //= 2
        d = 3
        while d &lt;= rn:
            while n%d==0: ds.append(d); n //= d
            d += 2
        if n &gt; 1: ds.append(n)
        return &quot; &quot;.join(map(str, ds))

class Float(Num):
    name, descr = &quot;flt32&quot;, &quot;32 bit Float&quot;
    def __init__(self, val): self.val = float(val)
    def __str__(self): return &quot;&quot;&quot;%s
    ieee: 0x%08X&quot;&quot;&quot;%(   self.val,
        ieee_int32(self.val),
    )

class Double(Num):
    name, descr = &quot;flt64&quot;, &quot;64 bit Float&quot;
    def __init__(self, val): self.val = float(val)
    def __str__(self): return &quot;&quot;&quot;%s
    ieee: 0x%16X&quot;&quot;&quot;%(   self.val,
                        ieee_int64(self.val),
    )

class Rat(Num):
    name, descr = &quot;rat&quot;, &quot;Rational&quot;
    def __init__(self, val):
        if isinstance(val, float):
            self.val = Fraction(&quot;%.53f&quot;%(val)).limit_denominator(1000000000)
        elif isinstance(val, Num): self.val = val.val
        else: self.val = Fraction(val)
    def __int__(self): return self.val.numerator//self.val.denominator
    def __float__(self): return self.val.numerator/self.val.denominator
    def __str__(self): return str(self.val)

class Int(Num):
    name, descr = &quot;int&quot;, &quot;Integer&quot;
    def __init__(self, val): self.val = int(val)
    def __truediv__(x, y): return x.__class__(x.val // y.val)
    def __str__(self): return base(self.val, radix=10, group=3, width=None)

class Int8(Num):
    name, descr = &quot;int8&quot;, &quot;8 bit Integer&quot;
    width = 8
    def __init__(self, val): self.val = int(val) &amp; (2**self.width-1)
    def __truediv__(x, y): return x.__class__(x.val // y.val)
    def __str__(self): return &quot;&quot;&quot;%s
    hex: %s
    oct: %s
    bin: %s&quot;&quot;&quot;%(    base(self.val, radix=10, group=3, width=None),
                    base(self.val, radix=16, group=4, width=self.width),
                    base(self.val, radix=8,  group=3, width=self.width),
                    base(self.val, radix=2,  group=4, width=self.width),
    )
    def rev(self):
        &quot;&quot;&quot; reverse bit order &quot;&quot;&quot;
        return self.__class__(
            sum(    ((self.val&gt;&gt;i)&amp;0x1)&lt;&lt;(self.width-1-i)
                    for i in range(self.width)
            )
        )

class Int16(Int8):
    name, descr = &quot;int16&quot;, &quot;16 bit Integer&quot;
    width = 16
    def __str__(self): return &quot;&quot;&quot;%s
    hex: %s
    bin: %s&quot;&quot;&quot;%(    base(self.val, radix=10, group=3, width=None),
                    base(self.val, radix=16, group=4, width=self.width),
                    base(self.val, radix=2,  group=4, width=self.width),
    )

class Int32(Int8):
    name, descr = &quot;int32&quot;, &quot;32 bit Integer&quot;
    width = 32
    def __str__(self): return &quot;&quot;&quot;%s
    hex: %s
    bin: %s
    flt: %s&quot;&quot;&quot;%(    base(self.val, radix=10, group=3, width=None),
                    base(self.val, radix=16, group=4, width=self.width),
                    base(self.val, radix=2,  group=4, width=self.width),
                    ieee_float(self.val),
    )

class Int64(Int32):
    name, descr = &quot;int64&quot;, &quot;64 bit Integer&quot;
    width = 64
    def __str__(self): return &quot;&quot;&quot;%s
    hex: %s
    bin: %s
    flt: %s&quot;&quot;&quot;%(    base(self.val, radix=10, group=3, width=None),
                    base(self.val, radix=16, group=4, width=self.width),
                    base(self.val, radix=2,  group=4, width=self.width),
                    ieee_double(self.val),
    )

def ieee_int32(x):
    return struct.unpack(&quot;I&quot;, struct.pack(&quot;f&quot;, x))[0]

def ieee_int64(x):
    return struct.unpack(&quot;Q&quot;, struct.pack(&quot;d&quot;, x))[0]

def ieee_float(n):
    return struct.unpack(&quot;f&quot;, struct.pack(&quot;I&quot;, n))[0]

def ieee_double(n):
    return struct.unpack(&quot;d&quot;, struct.pack(&quot;Q&quot;, n))[0]

class Calc:

    def __init__(self):

        self.number = Num

        def bin2int(n):
            n = n.replace('_', '')
            n = n.replace('b', '')
            return int(n, 2)

        def oct2int(n):
            n = n.replace('_', '')
            n = n.replace('o', '')
            return int(n, 8)

        def hex2int(n):
            n = n.replace('_', '')
            n = n.replace('h', '')
            if n.startswith('0x'): n = n[2:]
            return int(n, 16)

        def real2float(n):
            n = n.replace('_', '')
            return float(n)

        def dec2int(n):
            n = n.replace('_', '')
            return int(n)

        bin = (R(r'b[_0-1]+\b') | R(r'[_0-1]+b\b')) / bin2int
        oct = (R(r'o[_0-7]+\b') | R(r'[_0-7]+o\b')) / oct2int
        hex = ( R(r'h[_0-9a-fA-F]+\b') |
                R(r'[_0-9a-fA-F]+h\b') |
                R(r'0x[_0-9a-fA-F]+\b')) / hex2int
        real = R(r'(\d+\.\d*|\d*\.\d+)([eE][-+]?\d+)?|\d+[eE][-+]?\d+') / real2float
        dec = R(r'\d+') / dec2int
        var = R(r'[a-zA-Z_]\w*')

        from operator import pos, neg, invert, add, sub, or_, xor, \
                             mul, mod, truediv, floordiv, and_, \
                             rshift, lshift, pow as pow_
        op1 = lambda f,x: {'+':pos, '-':neg, '~':invert}[f](x)
        op = lambda f,y: lambda x: {'+':add, '-':sub,
                                    '*':mul, '%':mod, '/':truediv,
                                    '**':pow_,
                                    '&amp;':and_, '|':or_, '^':xor,
                                    '&gt;&gt;':rshift, '&lt;&lt;':lshift,
                                   }[f](x,y)
        def red(x, fs):
            for f in fs: x = f(x)
            return x

        with Separator(r'\s+'):

            expr = Rule()

            calc = ( K('?') / __doc__.strip()
                   | K('num') / self.mode(Num)
                   | K('int8') / self.mode(Int8)
                   | K('int16') / self.mode(Int16)
                   | K('int32') / self.mode(Int32)
                   | K('int64') / self.mode(Int64)
                   | K('int') / self.mode(Int)
                   | K('flt32') / self.mode(Float)
                   | K('flt64') / self.mode(Double)
                   | K('rat') / self.mode(Rat)
                   | (((var &amp; '=') | C('_')) &amp; expr) * self.assign
                   )

            fact = Rule()
            atom = ( '(' &amp; expr &amp; ')'
                   | (K('rev') &amp; '(' &amp; expr &amp; ')') / (lambda x: x.rev())
                   | (K('factor') &amp; '(' &amp; expr &amp; ')') / (lambda x: x.factor())
                   | (bin | oct | hex | real | dec | var / self.val)
                     / self.convert
                   )
            pow = (atom &amp; ((R(r'\*\*') &amp; fact) * op)[:1]) * red
            fact |= (R(r'\+|-|~') &amp; fact) * op1 | pow
            term = (fact &amp; ((R(r'\*|%|/|&amp;|&gt;&gt;|&lt;&lt;') &amp; fact) * op)[:]) * red
            expr |= (term &amp; ((R(r'\+|-|\||\^') &amp; term) * op)[:]) * red

        self.calc = calc
        self.var = {}

    def mode(self, m):
        def setmode(_):
            self.number = m
            return &quot;%s mode&quot;%self.number.descr
        return setmode

    def convert(self, x):
        return self.number(x)

    def assign(self, var, val):
        self.var[var] = val
        return str(val)

    def val(self, var):
        return self.var[var]

    def __call__(self, s):
        return self.calc(s)

def base(N, radix=10, group=3, width=None):
    if width:
        N %= 2**width
        bits_per_digit = {16:4, 8:3, 2:1}[radix]
        min_len = width//bits_per_digit
    s = &quot;&quot;
    while N:
        N, d = divmod(N, radix)
        s = s + &quot;0123456789ABCDEF&quot;[d]
    s = s or &quot;0&quot;
    if width:
        s = s + &quot;0&quot;*(min_len-len(s))
    s = &quot; &quot;.join(s[i:i+group] for i in range(0, len(s), group))
    return s[::-1]

if __name__ == '__main__':
    print(__doc__.strip())
    print()
    calc = Calc()
    for cmd in sys.argv[1:]:
        try:
            calc(cmd)
        except Exception as e:
            print(&quot;%s: %s&quot;%(e.__class__.__name__, e))
    while True:
        expr = input(&quot;(%s) &quot;%calc.number.name)
        if not expr: continue
        try:
            val = calc(expr)
        except Exception as e:
            print(&quot;%s: %s&quot;%(e.__class__.__name__, e))
        else:
            print(&quot;=&quot;, val)
        print()

</pre>
</div>
</div>
</div>
</div>
</body>
</html>
