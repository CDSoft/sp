<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.12: http://docutils.sourceforge.net/" />
<title>Simple Parser</title>
<meta name="author" content="Christophe Delord" />
<meta name="date" content="Sunday 14 August 2016" />
<style type="text/css">

/*
Author: Frederic Culot
Date: 2008-05-28
Copyright: This stylesheet has been placed in the public domain - free to edit and use for all uses.
*/
/*
Modified by C. Delord for Simple Parser
*/

/*@import url(html4css1.css);*/

body {
  font: 100% sans-serif;
  color: black;
  /*padding: 0em 2em;*/
}

@media screen {
  body {
    background: #003a6b;
    /*margin: 2em;*/
  }
  .document {
    border: 1px solid gray;
    margin: 0 auto;
    width: /*90%;*/ 95%;
    background-color: #ffffff;
    padding: 1.5em;
  }
}

@media print {
  body {
    background: #ffffff;
    margin: 0em;
  }
}

div.footer {
  text-align: right;
}

p.topic-title {
  font-weight: bold;
}

table.docinfo {
  text-align: left;
  margin: 2em 0em;
}

a[href] {
  color: #436976;
  background-color: transparent;
}

a.toc-backref {
  text-decoration: none;
}

h1 a[href] {
  color: #003a6b;
  text-decoration: none;
  background-color: transparent;
}

a.strong {
  font-weight: bold;
}

img {
  margin: 0;
  border: 0;
}

p {
  margin: 0.5em 0 1em 0;
  line-height: 1.5em;
}

p a:visited {
  color: purple;
  background-color: transparent;
}

p a:active {
  color: red;
  background-color: transparent;
}

a:hover {
  text-decoration: none;
}

p img {
  border: 0;
  margin: 0;
}

p.rubric {
  font-weight: bold;
  font-style: italic;
}

h1.title {
  color: #003a6b;
  font-size: 250%;
  margin-top: 0em;
  margin-bottom: 0em;
}

h2.subtitle {
  color: #003a6b;
  margin-top: 0.5em;
  margin-bottom: 0em;
  border-bottom: 1px solid #aaa;
}

h1, h2, h3, h4, h5, h6 {
  color: #555;
  background-color: transparent;
  margin: 0em;
  margin-top: 1em;
  padding-top: 0.5em;
  border: thin solid #aaa;    /* round borders on Mozilla */
  -moz-border-radius: 8px;
  padding: 2px;
}

h1 {
  font-size: 160%;
  margin-bottom: 0.5em;
  border-bottom: 2px solid #aaa;
  border-right: 2px solid #aaa;
  background-color: #eeeeee;
}

h2 {
  font-size: 140%;
  margin-bottom: 0.5em;
  border-bottom: 1px solid #aaa;
}

h3 {
  font-size: 130%;
  margin-bottom: 0.5em;
}

h4 {
  font-size: 110%;
  font-weight: bold;
  margin-bottom: 0.5em;
}

h5 {
  font-size: 105%;
  font-weight: bold;
  margin-bottom: 0.5em;
}

h6 {
  font-size: 100%;
  font-weight: bold;
  margin-bottom: 0.5em;
}

dt {
  font-style: italic;
}

dd {
  margin-bottom: 1.5em;
}

div.admonition, div.attention, div.danger, div.error, div.hint, div.note, div.tip, div.caution, div.important, div.warning {
  margin: 2em 2em;
  padding: 0em 1em;
  border-top: 1px solid #aaa;
  border-left: 1px solid #aaa;
  border-bottom: 2px solid #555;
  border-right: 2px solid #555;
}

p.admonition-title {
  font-weight: bold;
  border-bottom: 1px solid #aaa;
  padding-left: 30px;
}

table.docutils {
  text-align: left;
  border-left: 1px solid gray;
  border-collapse: collapse;
  width: 100%;
  margin: 0em 0em;
}

table.docutils caption {
  font-style: italic;
}

table.docutils td, table.docutils th {
  padding: 0.25em 0.5em;
}

table.docutils th {
  background-color: #dddddd;
}

div.sidebar {
  width: 33%;
  float: right;
  margin: 0em 2em;
  padding: 0em 1em;
  border-top: 1px solid #aaa;
  border-left: 1px solid #aaa;
  border-bottom: 2px solid #555;
  border-right: 2px solid #555;
}

p.sidebar-title {
  margin-bottom: 0em;
  color: #003a6b;
  border-bottom: 1px solid #aaa;
  font-weight: bold;
}

p.sidebar-subtitle {
  margin-top: 0em;
  font-style: italic;
  color: #003a6b;
}

pre, .pre {
  font-family: monospace;
  font-size: 1.1em;
  color: #444499;
}

pre.literal-block, pre.doctest-block {
  border: 1px solid gray;
  padding: 5px;
  background-color: #dddddd;
  margin: 0 5em 0 5em ;
}

div.footer, div.header {
    clear: both;
    font-size: smaller;
    color: white;
    background-color: transparent;
}

</style>
</head>
<body>
<div class="document" id="simple-parser">
<h1 class="title">Simple Parser</h1>
<h2 class="subtitle" id="how-to-easily-write-parsers-in-python">How to easily write parsers in Python</h2>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Christophe Delord</td></tr>
<tr class="field"><th class="docinfo-name">Web site:</th><td class="field-body"><a class="reference external" href="http://www.cdsoft.fr/sp">http://www.cdsoft.fr/sp</a></td>
</tr>
<tr><th class="docinfo-name">Date:</th>
<td>Sunday 14 August 2016</td></tr>
<tr class="field"><th class="docinfo-name">License:</th><td class="field-body">This software is released under the LGPL license.</td>
</tr>
<tr class="field"><th class="docinfo-name">Download:</th><td class="field-body"><a class="reference external" href="http://www.cdsoft.fr/sp/sp-v2.2.2.tgz">http://www.cdsoft.fr/sp/sp-v2.2.2.tgz</a></td>
</tr>
</tbody>
</table>
<!-- Simple Parser
Copyright (C) 2009-2016 Christophe Delord
http://www.cdsoft.fr/sp -->
<!-- This file is part of Simple Parser. -->
<!-- Simple Parser is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version. -->
<!-- Simple Parser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details. -->
<!-- You should have received a copy of the GNU Lesser General Public License
along with Simple Parser.  If not, see <http://www.gnu.org/licenses/>. -->
<div class="contents topic" id="table-of-contents">
<p class="topic-title first">Table of Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction-and-tutorial" id="id15">1&nbsp;&nbsp;&nbsp;Introduction and tutorial</a><ul class="auto-toc">
<li><a class="reference internal" href="#introduction" id="id16">1.1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference internal" href="#installation" id="id17">1.2&nbsp;&nbsp;&nbsp;Installation</a></li>
<li><a class="reference internal" href="#tutorial" id="id18">1.3&nbsp;&nbsp;&nbsp;Tutorial</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sp-reference" id="id19">2&nbsp;&nbsp;&nbsp;SP reference</a><ul class="auto-toc">
<li><a class="reference internal" href="#usage" id="id20">2.1&nbsp;&nbsp;&nbsp;Usage</a></li>
<li><a class="reference internal" href="#grammar-structure" id="id21">2.2&nbsp;&nbsp;&nbsp;Grammar structure</a></li>
<li><a class="reference internal" href="#lexer" id="id22">2.3&nbsp;&nbsp;&nbsp;Lexer</a></li>
<li><a class="reference internal" href="#parser" id="id23">2.4&nbsp;&nbsp;&nbsp;Parser</a></li>
<li><a class="reference internal" href="#performances-and-memory-consumption" id="id24">2.5&nbsp;&nbsp;&nbsp;Performances and memory consumption</a></li>
</ul>
</li>
<li><a class="reference internal" href="#older-python-versions" id="id25">3&nbsp;&nbsp;&nbsp;Older Python versions</a><ul class="auto-toc">
<li><a class="reference internal" href="#separators" id="id26">3.1&nbsp;&nbsp;&nbsp;Separators</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sp-mini-language" id="id27">4&nbsp;&nbsp;&nbsp;SP mini language</a></li>
<li><a class="reference internal" href="#some-examples-to-illustrate-sp" id="id28">5&nbsp;&nbsp;&nbsp;Some examples to illustrate SP</a><ul class="auto-toc">
<li><a class="reference internal" href="#newick-format" id="id29">5.1&nbsp;&nbsp;&nbsp;Newick format</a></li>
<li><a class="reference internal" href="#infix-prefix-postfix-notation-converter" id="id30">5.2&nbsp;&nbsp;&nbsp;Infix/Prefix/Postfix notation converter</a></li>
<li><a class="reference internal" href="#complete-interactive-calculator" id="id31">5.3&nbsp;&nbsp;&nbsp;Complete interactive calculator</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction-and-tutorial">
<h1><a class="toc-backref" href="#id15">1&nbsp;&nbsp;&nbsp;Introduction and tutorial</a></h1>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id16">1.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>SP (Simple Parser) is a Python <a class="footnote-reference" href="#id2" id="id1">[1]</a> parser generator.
It is aimed at easy usage rather than performance.
SP produces
<a class="reference external" href="http://en.wikipedia.org/wiki/Top-down_parser">Top-Down</a>
<a class="reference external" href="http://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive descent</a>
parsers.
SP also uses <a class="reference external" href="http://en.wikipedia.org/wiki/Memoization">memoization</a>
to optimize parsers' speed when dealing with ambiguous grammars.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Python is a wonderful object oriented programming language available at <a class="reference external" href="http://www.python.org">http://www.python.org</a></td></tr>
</tbody>
</table>
<div class="section" id="license">
<h3>License</h3>
<p>SP is available under the GNU Lesser General Public:</p>
<pre class="literal-block">
Simple Parser: A Python parser generator

Copyright (C) 2009-2016 Christophe Delord

Simple Parser is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Simple Parser is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Simple Parser.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
</pre>
</div>
<div class="section" id="structure-of-the-document">
<h3>Structure of the document</h3>
<dl class="docutils">
<dt><a class="reference internal" href="#introduction-and-tutorial">Introduction and tutorial</a></dt>
<dd>starts smoothly with a gentle tutorial as an introduction.
I think this tutorial may be sufficent to start with SP.</dd>
<dt><a class="reference internal" href="#sp-reference">SP reference</a></dt>
<dd>is a reference documentation. It will detail SP as much as possible.</dd>
<dt><a class="reference internal" href="#some-examples-to-illustrate-sp">Some examples to illustrate SP</a></dt>
<dd>gives the reader some examples to illustrate SP.</dd>
</dl>
</div>
</div>
<div class="section" id="installation">
<h2><a class="toc-backref" href="#id17">1.2&nbsp;&nbsp;&nbsp;Installation</a></h2>
<div class="section" id="getting-sp">
<h3>Getting SP</h3>
<p>SP is freely available on its web page (<a class="reference external" href="http://www.cdsoft.fr/sp">http://www.cdsoft.fr/sp</a>).</p>
</div>
<div class="section" id="requirements">
<h3>Requirements</h3>
<p>SP is a <em>pure Python</em> package.
It may run on <em>any platform</em> supported by Python.
The only requirement of SP is <em>Python 2.6</em>, <em>Python 3.1</em> or newer <a class="footnote-reference" href="#id4" id="id3">[2]</a>.
Python can be downloaded at <a class="reference external" href="http://www.python.org">http://www.python.org</a>.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Older <em>Python</em> versions may work (tested with Python 2.4 and 2.5).
See the <a class="reference internal" href="#older-python-versions">Older Python versions</a> chapter.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="tutorial">
<h2><a class="toc-backref" href="#id18">1.3&nbsp;&nbsp;&nbsp;Tutorial</a></h2>
<div class="section" id="id5">
<h3>Introduction</h3>
<p>This short tutorial presents how to make a simple calculator.
The calculator will compute basic mathematical expressions (<tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">*</tt>, <tt class="docutils literal">/</tt>) possibly nested in parenthesis.
We assume the reader is familiar with regular expressions.</p>
</div>
<div class="section" id="defining-the-grammar">
<h3>Defining the grammar</h3>
<p>Expressions are defined with a grammar.
For example an expression is a sum of terms and a term is a product of factors.
A factor is either a number or a complete expression in parenthesis.</p>
<p>We describe such grammars with rules.
A rule describes the composition of an item of the language.
In our grammar we have 3 items (expr, term, factor).
We will call these items <em>symbols</em> or <em>non terminal symbols</em>.
The decomposition of a symbol is symbolized with <tt class="docutils literal"><span class="pre">-&gt;</span></tt>.</p>
<p>Grammar for expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Grammar rule</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">expr <span class="pre">-&gt;</span> term <span class="pre">(('+'|'-')</span> term)*</tt></td>
<td>An expression is a term eventually followed
with a plus (<tt class="docutils literal">+</tt>) or a minus (<tt class="docutils literal">-</tt>) sign
and an other term any number of times
(<tt class="docutils literal">*</tt> is a repetition of an expression 0 or more times).</td>
</tr>
<tr><td><tt class="docutils literal">term <span class="pre">-&gt;</span> fact <span class="pre">(('*'|'/')</span> fact)*</tt></td>
<td>A term is a factor eventually followed
with a <tt class="docutils literal">*</tt> or <tt class="docutils literal">/</tt> sign
and an other factor any number of times.</td>
</tr>
<tr><td><tt class="docutils literal">fact <span class="pre">-&gt;</span> <span class="pre">('+'|'-')</span> fact | number | '(' expr ')'</tt></td>
<td>A factor is either a factor precedeed by a sign, a number
or an expression in parenthesis.</td>
</tr>
</tbody>
</table>
<p>We have defined here the grammar rules (i.e. the sentences of the language).
We now need to describe the lexical items (i.e. the words of the language).
These words - also called <em>terminal symbols</em> - are described using regular expressions.
In the rules we have written some of these terminal symbols (<tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">*</tt>, <tt class="docutils literal">/</tt>, <tt class="docutils literal">(</tt>, <tt class="docutils literal">)</tt>).
We have to define <tt class="docutils literal">number</tt>.
For sake of simplicity numbers are integers composed of digits (the corresponding regular expression can be <tt class="docutils literal"><span class="pre">[0-9]+</span></tt>).
To simplify the grammar and then the Python script we define two terminal symbols to group the operators (additive and multiplicative operators).
We can also define a special symbol that is ignored by SP.
This symbol is used as a separator.
This is generaly useful for white spaces and comments.</p>
<p>Terminal symbol definition for expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="37%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Terminal symbol</th>
<th class="head">Regular expression</th>
<th class="head">Comment</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">number</tt></td>
<td><tt class="docutils literal"><span class="pre">[0-9]+</span> or \d+</tt></td>
<td>One or more digits</td>
</tr>
<tr><td><tt class="docutils literal">addop</tt></td>
<td><tt class="docutils literal"><span class="pre">[+-]</span></tt></td>
<td>a <tt class="docutils literal">+</tt> or a <tt class="docutils literal">-</tt></td>
</tr>
<tr><td><tt class="docutils literal">mulop</tt></td>
<td><tt class="docutils literal"><span class="pre">[*/]</span></tt></td>
<td>a <tt class="docutils literal">*</tt> or a <tt class="docutils literal">/</tt></td>
</tr>
<tr><td><tt class="docutils literal">spaces</tt></td>
<td><tt class="docutils literal">\s+</tt></td>
<td>One or more spaces</td>
</tr>
</tbody>
</table>
<p>This is sufficient to define our parser with SP.</p>
<p>Grammar of the expression recognizer:</p>
<pre class="literal-block">
def Calc():

    number = R(r'[0-9]+')
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= addop &amp; fact
        fact |= '(' &amp; expr &amp; ')'
        fact |= number
        term = fact &amp; ( mulop &amp; fact )[:]
        expr |= term &amp; ( addop &amp; term )[:]

    return expr
</pre>
<p><tt class="docutils literal">Calc</tt> is the name of the Python function that returns a parser.
This function returns <tt class="docutils literal">expr</tt> which is the <em>axiom</em> <a class="footnote-reference" href="#axiom" id="id6">[3]</a> of the grammer.</p>
<p><tt class="docutils literal">expr</tt> and <tt class="docutils literal">fact</tt> are recursive rules.
They are first declared as empty rules (<tt class="docutils literal">expr = Rule()</tt>) and alternatives are later added (<tt class="docutils literal">expr |= ...</tt>).</p>
<p>Slices are used to implement repetitions.
<tt class="docutils literal"><span class="pre">foo[:]</span></tt> parses <tt class="docutils literal">foo</tt> zero or more times, which is equivalent to <tt class="docutils literal">foo*</tt> in a classical grammar notation.</p>
<p>The grammar can also be defined with the mini grammar language provided by SP:</p>
<pre class="literal-block">
def Calc():
    return compile(&quot;&quot;&quot;
        number = r'[0-9]+' ;
        addop = r'[+-]' ;
        mulop = r'[*/]' ;

        separator: r'\s+' ;

        !expr = term (addop term)* ;
        term = fact (mulop fact)* ;
        fact = addop fact ;
        fact = '(' expr ')' ;
        fact = number ;
    &quot;&quot;&quot;)
</pre>
<p>Here the <em>axiom</em> <a class="footnote-reference" href="#axiom" id="id7">[3]</a> is identified by <tt class="docutils literal">!</tt>.</p>
<p>With this small grammar we can only recognize a correct expression.
We will see in the next sections how to read the actual expression and to compute its value.</p>
<table class="docutils footnote" frame="void" id="axiom" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id7">2</a>)</em> The axiom is the symbol from which the parsing starts</td></tr>
</tbody>
</table>
</div>
<div class="section" id="reading-the-input-and-returning-values">
<h3>Reading the input and returning values</h3>
<p>The input of the grammar is a string.
To do something useful we need to read this string in order to transform it into an expected result.</p>
<p>This string can be read by catching the return value of terminal symbols.
By default any terminal symbol returns a string containing the current token.
So the token <tt class="docutils literal">'('</tt> always returns the string <tt class="docutils literal">'('</tt>.
For some tokens it may be useful to compute a Python object from the token.
For example <tt class="docutils literal">number</tt> should return an integer instead of a string,
<tt class="docutils literal">addop</tt> and <tt class="docutils literal">mulop</tt>, followed by a number, should return a function corresponding to the operator.
That's why we will add a function to the token and rule definitions.
So we associate <tt class="docutils literal">int</tt> to <tt class="docutils literal">number</tt> and <tt class="docutils literal">op1</tt> and <tt class="docutils literal">op2</tt> to unary and binary operators.</p>
<p><tt class="docutils literal">int</tt> is a Python function converting objects to integers and <tt class="docutils literal">op1</tt> and <tt class="docutils literal">op2</tt> are user defined functions.</p>
<p><tt class="docutils literal">op1</tt> and <tt class="docutils literal">op2</tt> functions:</p>
<pre class="literal-block">
op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

# red applyies functions to a number
def red(x, fs):
    for f in fs: x = f(x)
    return x
</pre>
<dl class="docutils">
<dt>To associate a function to a token or a rule it must be applyed using <tt class="docutils literal">/</tt> or <tt class="docutils literal">*</tt> operators:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal">/</tt> applyies a function to an object returned by a (sub)parser.</li>
<li><tt class="docutils literal">*</tt> applyies a function to an tuple of objects returned by a sequence of (sub) parsers.</li>
</ul>
</dd>
</dl>
<p>Token and rule definitions with functions:</p>
<pre class="literal-block">
number = R(r'[0-9]+') / int

fact |= (addop &amp; fact) * op1
term = (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red

# R(r'[0-9]+') applyed on &quot;42&quot; will return &quot;42&quot;.
# R(r'[0-9]+') / int will return int(&quot;42&quot;)

# addop &amp; fact applyied on &quot;+ 42&quot; will return ('+', 42)
# (addop &amp; fact) * op1 will return op1(*('+', 42)), i.e. op1('+', 42)
# so (addop &amp; fact) * op1 returns +42

# (addop &amp; fact) * op2 will return op2(*('+', 42)), i.e. op2('+', 42)
# so (addop &amp; fact) * op2 returns lambda x: add(x, 42)

# fact &amp; ( (mulop &amp; fact) * op2 )[:] returns a number and a list of functions
# for instance (42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
# so (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red applyied on &quot;42*43*44&quot;
# will return red(42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
# i.e. 42*43*44
</pre>
<p>And with the SP language:</p>
<pre class="literal-block">
number = r'[0-9]+' : `int` ;

addop = r'[+-]' ;
mulop = r'[*/]' ;

fact = addop fact :: `op1` ;
term = fact (mulop fact :: `op2`)* :: `red` ;

# r'[0-9]+' applyed on &quot;42&quot; will return &quot;42&quot;.
# r'[0-9]+' : `int` will return int(&quot;42&quot;)

# &quot;addop fact&quot; applyied on &quot;+ 42&quot; will return ('+', 42)
# &quot;addop fact :: `op1`&quot; will return op1(*('+', 42)), i.e. op1('+', 42)
# so &quot;addop fact :: `op1`&quot; returns +42

# &quot;addop fact :: `op2`&quot; will return op2(*('+', 42)), i.e. op2('+', 42)
# so &quot;addop fact :: `op2`&quot; returns lambda x: add(x, 42)

# &quot;fact (mulop fact :: `op2`)*&quot; returns a number and a list of functions
# for instance (42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
# so &quot;fact (mulop fact :: `op2`)* :: `red`&quot; applyied on &quot;42*43*44&quot;
# will return red(42, [(lambda x:mul(x, 43)), (lambda x:mul(x, 44))])
# i.e. 42*43*44
</pre>
<p>In the SP language, <tt class="docutils literal">:</tt> (as <tt class="docutils literal">/</tt>) applies a Python function (more generally a callable object)
to a value returned by a sequence and <tt class="docutils literal">::</tt> (as <tt class="docutils literal">*</tt>) applies a Python function to several values
returned by a sequence.</p>
<p>Here is finally the complete parser.</p>
<p>Expression recognizer and evaluator:</p>
<pre class="literal-block">
from sp import *

def Calc():

    from operator import pos, neg, add, sub, mul, truediv as div

    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    def red(x, fs):
        for f in fs: x = f(x)
        return x

    number = R(r'[0-9]+') / int
    addop = R('[+-]')
    mulop = R('[*/]')

    with Separator(r'\s+'):

        expr = Rule()
        fact = Rule()
        fact |= (addop &amp; fact) * op1
        fact |= '(' &amp; expr &amp; ')'
        fact |= number
        term = (fact &amp; ( (mulop &amp; fact) * op2 )[:]) * red
        expr |= (term &amp; ( (addop &amp; term) * op2 )[:]) * red

    return expr
</pre>
<p>Or with SP language:</p>
<pre class="literal-block">
from sp import *

def Calc():

    from operator import pos, neg, add, sub, mul, truediv as div

    op1 = lambda f,x: {'+':pos, '-':neg}[f](x)
    op2 = lambda f,y: lambda x: {'+': add, '-': sub, '*': mul, '/': div}[f](x,y)

    def red(x, fs):
        for f in fs: x = f(x)
        return x

    return compile(&quot;&quot;&quot;
        number = r'[0-9]+' : `int` ;
        addop = r'[+-]' ;
        mulop = r'[*/]' ;

        separator: r'\s+' ;

        !expr = term (addop term :: `op2`)* :: `red` ;
        term = fact (mulop fact :: `op2`)* :: `red` ;
        fact = addop fact :: `op1` ;
        fact = '(' expr ')' ;
        fact = number ;
    &quot;&quot;&quot;)
</pre>
</div>
<div class="section" id="embeding-the-parser-in-a-script">
<h3>Embeding the parser in a script</h3>
<p>A parser is a simple Python object.
This example show how to write a function that returns a parser.
The parser can be applyied to strings by simply calling the parser.</p>
<p>Writting SP grammars in Python:</p>
<pre class="literal-block">
from sp import *

def MyParser():

    parser = ...

    return parser

# You can instanciate your parser here
my_parser = MyParser()

# and use it
parsed_object = my_parser(string_to_be_parsed)
</pre>
<p>To use this parser you now just need to instanciate an object.</p>
<p>Complete Python script with expression parser:</p>
<pre class="literal-block">
from sp import *

def Calc():

    ...

calc = Calc()
while True:
    expr = input('Enter an expression: ')
    try: print(expr, '=', calc(expr))
    except Exception as e: print(&quot;%s:&quot;%e.__class__.__name__, e)
</pre>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>This tutorial shows some of the possibilities of SP.
If you have read it carefully you may be able to start with SP.
The next chapters present SP more precisely.
They contain more examples to illustrate all the features of SP.</p>
<p>Happy SP'ing!</p>
</div>
</div>
</div>
<div class="section" id="sp-reference">
<h1><a class="toc-backref" href="#id19">2&nbsp;&nbsp;&nbsp;SP reference</a></h1>
<div class="section" id="usage">
<h2><a class="toc-backref" href="#id20">2.1&nbsp;&nbsp;&nbsp;Usage</a></h2>
<p>SP is a package which main function is to provide basic objects to build a complete parser.</p>
<p>The grammar is a Python object.</p>
<p>Grammar embeding example:</p>
<pre class="literal-block">
def Foo():
    bar = R('bar')
    return bar
</pre>
<p>Then you can use the new generated parser.
The parser is simply a Python object.</p>
<p>Parser usage example:</p>
<pre class="literal-block">
test = &quot;bar&quot;
my_parser = Foo()
x = my_parser(test)               # Parses &quot;bar&quot;
print x
</pre>
</div>
<div class="section" id="grammar-structure">
<h2><a class="toc-backref" href="#id21">2.2&nbsp;&nbsp;&nbsp;Grammar structure</a></h2>
<p>SP grammars are Python objects.
SP grammars may contain two parts:</p>
<dl class="docutils">
<dt>Tokens</dt>
<dd>are built by the <tt class="docutils literal">R</tt> or <tt class="docutils literal">K</tt> keywords.</dd>
<dt>Rules</dt>
<dd>are described after tokens in a <tt class="docutils literal">Separator</tt> context.</dd>
</dl>
<p>Example of SP grammar structure:</p>
<pre class="literal-block">
def Foo():

    # Tokens
    number = R(r'\d+') / int

    # Rules
    with Separator(r'\s+'):
        S = number[:]

    return S

foo = Foo()
result = foo(&quot;42 43 44&quot;) # return [42, 43, 44]
</pre>
</div>
<div class="section" id="lexer">
<h2><a class="toc-backref" href="#id22">2.3&nbsp;&nbsp;&nbsp;Lexer</a></h2>
<div class="section" id="regular-expression-syntax">
<h3>Regular expression syntax</h3>
<p>The lexer is based on the <em>re</em> <a class="footnote-reference" href="#id10" id="id8">[4]</a> module.
SP profits from the power of Python regular expressions.
This document assumes the reader is familiar with regular expressions.</p>
<p>You can use the syntax of regular expressions as expected by the <em>re</em> <a class="footnote-reference" href="#id11" id="id9">[5]</a> module.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td><em>re</em> is a standard Python module.
It handles regular expressions.
For further information about <em>re</em> you can read <a class="reference external" href="http://docs.python.org/library/re.html">http://docs.python.org/library/re.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[5]</a></td><td>Read the Python documentation for further information: <a class="reference external" href="http://docs.python.org/library/re.html#re-syntax">http://docs.python.org/library/re.html#re-syntax</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="predefined-tokens">
<h3>Predefined tokens</h3>
<p>Tokens can be explicitely defined by the <tt class="docutils literal">R</tt>, <tt class="docutils literal">K</tt> and <tt class="docutils literal">Separator</tt> keywords.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">R</tt></td>
<td>defines a regular token.
The token is defined with a regular expression and returns a string
(or a tuple of strings if the regular expression defines groups).</td>
</tr>
<tr><td><tt class="docutils literal">K</tt></td>
<td>defines a token that returns nothing (useful for keywords for instance).
The keyword is defined by an identifier (in this case word boundaries
are expected around the keyword) or another string (in this case the
pattern is not considered as a regular expression).
The token just recognizes a keyword and returns nothing.</td>
</tr>
<tr><td><tt class="docutils literal">Separator</tt></td>
<td>is a context manager used to define separators for the rules defined
in the context.
The token is defined with a regular expression and returns nothing.</td>
</tr>
</tbody>
</table>
<p>A token can be defined by:</p>
<dl class="docutils">
<dt>a name</dt>
<dd>which identifies the token.
This name is used by the parser.</dd>
<dt>a regular expression</dt>
<dd>which describes what to match to recognize the token.</dd>
<dt>an action</dt>
<dd>which can translate the matched text into a Python object.
It can be a function of one argument or a non callable object.
If it is not callable, it will be returned for each token
otherwise it will be applied to the text of the token and the result will be returned.
This action is optional. By default the token text is returned.</dd>
</dl>
<p>Token definition examples:</p>
<pre class="literal-block">
integer = R(r'\d+') / int
identifier = R(r'[a-zA-Z]\w*\b')
boolean = R(r'(True|False)\b') / (lambda b: b=='True')

spaces = K(r'\s+')
comments = K(r'#.*')

with Separator(spaces|comments):
    # rules defined here will use spaces and comments as separators
    atom = '(' &amp; expr &amp; ')'
</pre>
<p>There are two kinds of tokens.
Tokens defined by the <tt class="docutils literal">R</tt> or <tt class="docutils literal">K</tt> keywords are parsed by the parser
and tokens defined by the <tt class="docutils literal">Separator</tt> keyword are considered as separators
(white spaces or comments for example) and are wiped out by the lexer.</p>
<p>The word boundary <tt class="docutils literal">\b</tt> can be used to avoid recognizing &quot;True&quot; at the beginning of &quot;Truexyz&quot;.</p>
<p>If the regular expression defines groups,
the parser returns a tuple containing these groups:</p>
<pre class="literal-block">
couple = R('&lt;(\d+)-(\d+)&gt;')

couple(&quot;&lt;42-43&gt;&quot;) == ('42', '43')
</pre>
<p>If the regular expression defines only one group,
the parser returns the value of this group:</p>
<pre class="literal-block">
first = R('&lt;(\d+)-\d+&gt;')

first(&quot;&lt;42-43&gt;&quot;) == '42'
</pre>
<p>Unwanted groups can be avoided using <tt class="docutils literal"><span class="pre">(?:...)</span></tt>.</p>
<p>A name can be given to a token to make error messages easier to read:</p>
<pre class="literal-block">
couple = R('&lt;(\d+)-(\d+)&gt;', name=&quot;couple&quot;)
</pre>
<p>Regular expressions can be compiled using specific compilation options.
Options are defined in the <tt class="docutils literal">re</tt> module:</p>
<pre class="literal-block">
token = R('...', flags=re.IGNORECASE|re.DOTALL)
</pre>
<p><tt class="docutils literal">re</tt> defines the following flags:</p>
<dl class="docutils">
<dt>I (IGNORECASE)</dt>
<dd>Perform case-insensitive matching.</dd>
<dt>L (LOCALE)</dt>
<dd>Make <tt class="docutils literal">\w</tt>, <tt class="docutils literal">\W</tt>, <tt class="docutils literal">\b</tt>, <tt class="docutils literal">\B</tt>, dependent on the current locale.</dd>
<dt>M (MULTILINE)</dt>
<dd><tt class="docutils literal">&quot;^&quot;</tt> matches the beginning of lines (after a newline)
as well as the string.
<tt class="docutils literal">&quot;$&quot;</tt> matches the end of lines (before a newline) as well
as the end of the string.</dd>
<dt>S (DOTALL)</dt>
<dd><tt class="docutils literal">&quot;.&quot;</tt> matches any character at all, including the newline.</dd>
<dt>X (VERBOSE)</dt>
<dd>Ignore whitespace and comments for nicer looking RE's.</dd>
<dt>U (UNICODE)</dt>
<dd>Make <tt class="docutils literal">\w</tt>, <tt class="docutils literal">\W</tt>, <tt class="docutils literal">\b</tt>, <tt class="docutils literal">\B</tt>, dependent on the Unicode locale</dd>
</dl>
</div>
<div class="section" id="inline-tokens">
<h3>Inline tokens</h3>
<p>Tokens can also be defined on the fly.
Their definition are then inlined in the grammar rules.
This feature may be useful for keywords or punctuation signs.</p>
<p>In this case tokens can be written without the <tt class="docutils literal">R</tt> or <tt class="docutils literal">K</tt> keywords.
They are considered as keywords (as defined by <tt class="docutils literal">K</tt>).</p>
<p>Inline token definition examples:</p>
<pre class="literal-block">
IfThenElse = 'if' &amp; Cond &amp;
             'then' &amp; Statement &amp;
             'else' &amp; Statement
</pre>
</div>
</div>
<div class="section" id="parser">
<h2><a class="toc-backref" href="#id23">2.4&nbsp;&nbsp;&nbsp;Parser</a></h2>
<div class="section" id="declaration">
<h3>Declaration</h3>
<p>A parser is declared as a Python object.</p>
</div>
<div class="section" id="grammar-rules">
<h3>Grammar rules</h3>
<p>Rule declarations have two parts.
The left side declares the symbol associated to the rule.
The right side describes the decomposition of the rule.
Both parts of the declaration are separated with an equal sign (<tt class="docutils literal">=</tt>).</p>
<p>Rule declaration example:</p>
<pre class="literal-block">
SYMBOL = (A &amp; B) * (lambda a, b: f(a, b))
</pre>
</div>
<div class="section" id="sequences">
<h3>Sequences</h3>
<p>Sequences in grammar rules describe in which order symbols should appear in the input string.
For example the sequence <tt class="docutils literal">A &amp; B</tt> recognizes an <tt class="docutils literal">A</tt> followed by a <tt class="docutils literal">B</tt>.</p>
<p>For example to say that a <tt class="docutils literal">sum</tt> is a <tt class="docutils literal">term</tt> plus another <tt class="docutils literal">term</tt> you can write:</p>
<pre class="literal-block">
Sum = Term &amp; '+' &amp; Term
</pre>
</div>
<div class="section" id="alternatives">
<h3>Alternatives</h3>
<p>Alternatives in grammar rules describe several possible decompositions of a symbol.
The infix pipe operator (<tt class="docutils literal">|</tt>) is used to separate alternatives.
<tt class="docutils literal">A | B</tt> recognizes either an <tt class="docutils literal">A</tt> or a <tt class="docutils literal">B</tt>.
If both <tt class="docutils literal">A</tt> and <tt class="docutils literal">B</tt> can be matched only the first longest match is considered.
So the order of alternatives may be very important
when two alternatives can match texts of the same size.</p>
<p>For example to say that an <tt class="docutils literal">atom</tt> is an <em>integer</em> or an <em>expression in paranthesis</em>
you can write:</p>
<pre class="literal-block">
Atom = integer | '(' &amp; Expr &amp; ')'
</pre>
</div>
<div class="section" id="repetitions">
<h3>Repetitions</h3>
<p>Repetitions in grammar rules describe how many times an expression should be matched.</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">Usage</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">A[:1]</span></tt></td>
<td>recognizes zero or one <tt class="docutils literal">A</tt>.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">A[:]</span></tt></td>
<td>recognizes zero or more <tt class="docutils literal">A</tt>.</td>
</tr>
<tr><td><tt class="docutils literal">A[1:]</tt></td>
<td>recognizes one or more <tt class="docutils literal">A</tt>.</td>
</tr>
<tr><td><tt class="docutils literal">A[m:n]</tt></td>
<td>recognizes at least m and at most n <tt class="docutils literal">A</tt>.</td>
</tr>
<tr><td><tt class="docutils literal">A[m:n:s]</tt></td>
<td>recognizes at least m and at most n <tt class="docutils literal">A</tt> using <tt class="docutils literal">s</tt> as a separator.</td>
</tr>
</tbody>
</table>
<p>Repetitions are greedy.
Repetitions are implemented as Python loops.
Thus whatever the length of the repetitions, the Python stack will not overflow.</p>
<p>The separator is useful to parse lists.
For instance a comma separated parameter list is <tt class="docutils literal"><span class="pre">parameter[::',']</span></tt>.</p>
</div>
<div class="section" id="precedence-and-grouping">
<h3>Precedence and grouping</h3>
<p>The following table lists the different structures in increasing precedence order.
To override the default precedence you can group expressions with parenthesis.</p>
<p>Precedence in SP expressions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Structure</th>
<th class="head">Example</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Alternative</td>
<td><tt class="docutils literal">A | B</tt></td>
</tr>
<tr><td>Sequence</td>
<td><tt class="docutils literal">A &amp; B</tt></td>
</tr>
<tr><td>Repetitions</td>
<td><tt class="docutils literal">A[x:y]</tt></td>
</tr>
<tr><td>Symbol and grouping</td>
<td><tt class="docutils literal">A</tt> and <tt class="docutils literal">( ... )</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="actions">
<h3>Actions</h3>
<p>Grammar rules can contain actions as Python functions.</p>
<p>Functions are applyied to parsed objects using <tt class="docutils literal">/</tt> or <tt class="docutils literal">*</tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Expression</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal">parser / function</tt></td>
<td>returns <em>function(result of parser)</em>.</td>
</tr>
<tr><td><tt class="docutils literal">parser * function</tt></td>
<td>returns <em>function(*result of parser)</em>.</td>
</tr>
</tbody>
</table>
<p><tt class="docutils literal">*</tt> can be used to analyse the result of a sequence.</p>
</div>
<div class="section" id="abstract-syntax-trees">
<h3>Abstract syntax trees</h3>
<p>An abstract syntax tree (AST) is an abstract representation of the structure of the input.
A node of an AST is a Python object (there is no constraint about its class).
AST nodes are completely defined by the user.</p>
<p>AST example (parsing a couple):</p>
<pre class="literal-block">
class Couple:
    def __init__(self, a, b):
        self.a = a
        self.b = b

def Foo():
    couple = ('(' &amp; item &amp; ',' &amp; item &amp; ')') * Couple
    return couple
</pre>
</div>
<div class="section" id="constants">
<h3>Constants</h3>
<p>It is sometimes useful to return a constant.
<tt class="docutils literal">C</tt> defines a parser that matches an empty input and returns a constant.</p>
<p>Constant example:</p>
<pre class="literal-block">
number = (  '1' &amp; C(&quot;one&quot;)
         |  '2' &amp; C(&quot;two&quot;)
         |  '3' &amp; C(&quot;three&quot;)
         )
</pre>
</div>
<div class="section" id="position-in-the-input-string">
<h3>Position in the input string</h3>
<p>To know the current position in the input string,
the <tt class="docutils literal">At()</tt> parser returns an object containing
the current index (attribute <tt class="docutils literal">index</tt>) and the
corresponding line and column numbers (attributes
<tt class="docutils literal">line</tt> and <tt class="docutils literal">column</tt>):</p>
<pre class="literal-block">
position = At() / `lambda p: (p.line, p.column)`
rule = ... &amp; pos &amp; ...
</pre>
</div>
</div>
<div class="section" id="performances-and-memory-consumption">
<h2><a class="toc-backref" href="#id24">2.5&nbsp;&nbsp;&nbsp;Performances and memory consumption</a></h2>
<p>Backtracking has a cost.
The parser may often try to parse again the same string at the same position.
To improve the speed of the parser, some time consumming functions are <em>memoized</em>.
This drastically fasten the parser but requires more memory.
If a lot of string are parsed in a single script this mechanism can slow down
the computer because of heavy swap disk usage or even lead to a memory error.</p>
<p>To avoid such problems it is recommanded to clean the memoization cache
by calling the <tt class="docutils literal">sp.clean</tt> function:</p>
<pre class="literal-block">
import sp

...

for s in a_lot_of_strings:
    parse(s)
    sp.clean()
</pre>
</div>
</div>
<div class="section" id="older-python-versions">
<h1><a class="toc-backref" href="#id25">3&nbsp;&nbsp;&nbsp;Older Python versions</a></h1>
<p>This document describes the usage of SP with Python 2.6 or Python 3.1.
Grammars need some adaptations to work with Python 2.5. or older.</p>
<div class="section" id="separators">
<h2><a class="toc-backref" href="#id26">3.1&nbsp;&nbsp;&nbsp;Separators</a></h2>
<p>Separators use context managers which don't exist in Python 2.4.
Context managers have been introduced in Python 2.5
(<tt class="docutils literal">from __future__ import with_statement</tt>)
and in Python 2.6 (as a standard feature).
When the context managers are not available, it may be possible
to call the <tt class="docutils literal">__enter__</tt> and <tt class="docutils literal">__exit__</tt> method explicitly
(tested for Python 2.4).</p>
<p>Python 2.6 and later:</p>
<pre class="literal-block">
number = R(r'\d+') / int
with Separator('\s+'):
    coord = number &amp; ',' &amp; number
</pre>
<p>Python 2.5 with <tt class="docutils literal">with_statement</tt>:</p>
<pre class="literal-block">
from __future__ import with_statement

number = R(r'\d+') / int
with Separator('\s+'):
    coord = number &amp; ',' &amp; number
</pre>
<p>Python 2.5 or 2.4 (or older but not tested) without <tt class="docutils literal">with_statement</tt>:</p>
<pre class="literal-block">
sep = Separator('\s+')

number = R(r'\d+') / int
sep.__enter__()
coord = number &amp; ',' &amp; number
sep.__exit__()
</pre>
</div>
</div>
<div class="section" id="sp-mini-language">
<h1><a class="toc-backref" href="#id27">4&nbsp;&nbsp;&nbsp;SP mini language</a></h1>
<p>Instead of using Python expressions that can sometimes be difficult to read,
it's possible to write grammars in a cleaner syntax and compile these
grammar with the <tt class="docutils literal">sp.compile</tt> function. This function takes the grammar as
a string parameter.  The <tt class="docutils literal">sp.compile_file</tt> function reads the grammar in a
separate file.</p>
<p>Here the equivalence between Python expressions and the SP mini language:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="35%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">SP Python expressions</th>
<th class="head">SP mini language</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">R(&quot;regular</span> expression&quot;)</tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">R(&quot;regexpr&quot;,</span> <span class="pre">name=&quot;name&quot;)</span></tt></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><tt class="docutils literal">r&quot;regular expression&quot;</tt></div>
<div class="line"><tt class="docutils literal">name.r&quot;regexpr&quot;</tt></div>
</div>
</td>
<td>Token defined by a
regular expression</td>
</tr>
<tr><td><div class="first last line-block">
<div class="line"><tt class="docutils literal"><span class="pre">K(&quot;plain</span> text&quot;)</tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">K(&quot;plain</span> text&quot;, <span class="pre">name=&quot;name&quot;)</span></tt></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><tt class="docutils literal">&quot;plain text&quot;</tt></div>
<div class="line"><tt class="docutils literal"><span class="pre">name.&quot;plain</span> text&quot;</tt></div>
</div>
</td>
<td>Keyword defined by a non
interpreted string</td>
</tr>
<tr><td><tt class="docutils literal">t = <span class="pre">R('...',</span> flags=re.I|re.S)</tt></td>
<td><tt class="docutils literal">lexer: I S; t = <span class="pre">r'...'</span></tt></td>
<td>Regular expression options</td>
</tr>
<tr><td><tt class="docutils literal">with <span class="pre">Separator(...):</span></tt></td>
<td><tt class="docutils literal">separator: ... ;</tt></td>
<td>Separator definition</td>
</tr>
<tr><td><tt class="docutils literal">C(object)</tt></td>
<td><tt class="docutils literal">`object`</tt></td>
<td>Parses nothing and
returns <tt class="docutils literal">object</tt></td>
</tr>
<tr><td><tt class="docutils literal">... / function</tt></td>
<td><tt class="docutils literal">... : `function`</tt></td>
<td>Parses ... and apply the result
to <tt class="docutils literal">function</tt>
(<tt class="docutils literal"><span class="pre">function(...)</span></tt>)</td>
</tr>
<tr><td><tt class="docutils literal">... * function</tt></td>
<td><tt class="docutils literal">... :: `function`</tt></td>
<td>Parses ... and apply the result
(multiple values) to <tt class="docutils literal">function</tt>
(<tt class="docutils literal"><span class="pre">function(*...)</span></tt>)</td>
</tr>
<tr><td><tt class="docutils literal">... &amp; At() &amp; ...</tt></td>
<td><tt class="docutils literal">... &#64; ...</tt></td>
<td>Position in the input string</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">(...)[:]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">(...)*</span></tt></td>
<td>Zero or more matches</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">(...)[1:]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">(...)+</span></tt></td>
<td>One or more matches</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">(...)[:1]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">(...)?</span></tt></td>
<td>Zero or one matche</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">(...)[::S]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">[.../S]*</span></tt></td>
<td>Zero or more matches
separated by <tt class="docutils literal">S</tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">(...)[1::S]</span></tt></td>
<td><tt class="docutils literal"><span class="pre">[.../S]+</span></tt></td>
<td>One or more matches
separated by <tt class="docutils literal">S</tt></td>
</tr>
<tr><td><tt class="docutils literal">A &amp; B &amp; C</tt></td>
<td><tt class="docutils literal">A B C</tt></td>
<td>Sequence</td>
</tr>
<tr><td><tt class="docutils literal">A | B | C</tt></td>
<td><tt class="docutils literal">A | B | C</tt></td>
<td>Alternative</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">(...)</span></tt></td>
<td><tt class="docutils literal"><span class="pre">(...)</span></tt></td>
<td>Grouping</td>
</tr>
<tr><td><tt class="docutils literal">rule_name = ...</tt></td>
<td><tt class="docutils literal">rule_name = ... ;</tt></td>
<td>Rule definition</td>
</tr>
<tr><td><tt class="docutils literal">axiom_name = ...</tt></td>
<td><tt class="docutils literal">!axiom_name = ... ;</tt></td>
<td>Axiom definition</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="some-examples-to-illustrate-sp">
<h1><a class="toc-backref" href="#id28">5&nbsp;&nbsp;&nbsp;Some examples to illustrate SP</a></h1>
<div class="section" id="newick-format">
<h2><a class="toc-backref" href="#id29">5.1&nbsp;&nbsp;&nbsp;Newick format</a></h2>
<pre class="literal-block">
In mathematics, Newick tree format (or Newick notation or New Hampshire tree format)
is a way to represent graph-theoretical trees with edge lengths using parentheses and
commas. It was created by James Archie, William H. E. Day, Joseph Felsenstein, Wayne
Maddison, Christopher Meacham, F. James Rohlf, and David Swofford, at two meetings in
1986, the second of which was at Newick's restaurant in Dover, New Hampshire, USA.

-- Wikipedia, the free encyclopedia
</pre>
<p>The grammar given by Wikipedia is:</p>
<pre class="literal-block">
Tree --&gt; Subtree &quot;;&quot; | Branch &quot;;&quot;
Subtree --&gt; Leaf | Internal
Leaf --&gt; Name
Internal --&gt; &quot;(&quot; BranchSet &quot;)&quot; Name
BranchSet --&gt; Branch | Branch &quot;,&quot; BranchSet
Branch --&gt; Subtree Length
Name --&gt; empty | string
Length --&gt; empty | &quot;:&quot; number
</pre>
<p>With very few transformation, this grammar can be converted to a Simple Parser grammar.
Only <tt class="docutils literal">BranchSet</tt> is rewritten to use a comma separated list parser:</p>
<pre class="literal-block">
Tree = Subtree ';' | Branch ';' ;
Subtree = Leaf | Internal ;
Leaf = Name ;
Internal = '(' [Branch/',']+ ')' Name ;
Branch = Subtree Length ;
Name = r'[^;:,()]*';
Length = '' | ':' r'[0-9.]+' ;
</pre>
<p>Here is the complete parser (newick.py):</p>
<pre class="literal-block">
#!/usr/bin/env python

# Simple Parser
# Copyright (C) 2009-2010 Christophe Delord
# http://www.cdsoft.fr/sp

# This file is part of Simple Parser.
# 
# Simple Parser is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Simple Parser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with Simple Parser.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

# from http://en.wikipedia.org/wiki/Newick_format

import sp

EXAMPLES = &quot;&quot;&quot;\
(,,(,));                               no nodes are named
(A,B,(C,D));                           leaf nodes are named
(A,B,(C,D)E)F;                         all nodes are named
(:0.1,:0.2,(:0.3,:0.4):0.5);           all but root node have a distance to parent
(:0.1,:0.2,(:0.3,:0.4):0.5):0.0;       all have a distance to parent
(A:0.1,B:0.2,(C:0.3,D:0.4):0.5);       distances and leaf names (popular)
(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;     distances and all names
((B:0.2,(C:0.3,D:0.4)E:0.5)F:0.1)A;    a tree rooted on a leaf node (rare)
&quot;&quot;&quot;

class Leaf:
    def __init__(self, name): self.name = name
    def __str__(self): return self.name
    def nb_leaves(self): return 1

class Internal:
    def __init__(self, subtrees, name):
        self.subtrees, self.name = subtrees, name
    def __str__(self):
        return &quot;(%s)%s&quot;%(
            ','.join(str(st) for st in self.subtrees),
            self.name
        )
    def nb_leaves(self):
        return sum(st.nb_leaves() for st in self.subtrees)

class Branch:
    def __init__(self, subtree, length):
        self.subtree, self.length = subtree, length
    def __str__(self):
        return &quot;%s:%s&quot;%(self.subtree, self.length)
    def nb_leaves(self):
        return self.subtree.nb_leaves()

parser = sp.compile(r&quot;&quot;&quot;
    !Tree = Subtree ';' | Branch ';' ;
    Subtree = Leaf | Internal ;
    Leaf = Name : `Leaf` ;
    Internal = '(' [Branch/',']+ ')' Name :: `Internal` ;
    Branch = Subtree Length :: `Branch` ;
    Name = r'[^;:,()]*';
    Length = ':' r'[0-9.]+' : `float` | `0.0` ;
&quot;&quot;&quot;)

for example in EXAMPLES.splitlines():
    example, description = example.split(' ', 1)
    description = description.strip()
    tree = parser(example)
    print(&quot;%s:&quot;%description)
    print(&quot;-&quot;*len(description))
    print(&quot;    Input : %s&quot;%example)
    print(&quot;    Parsed: %s&quot;%tree)
    print(&quot;    Leaves: %s&quot;%tree.nb_leaves())
    print(&quot;&quot;)

</pre>
</div>
<div class="section" id="infix-prefix-postfix-notation-converter">
<h2><a class="toc-backref" href="#id30">5.2&nbsp;&nbsp;&nbsp;Infix/Prefix/Postfix notation converter</a></h2>
<div class="section" id="id12">
<h3>Introduction</h3>
<p>In the previous example, the parser computes the value of the expression on the fly, while parsing.
It is also possible to build an abstract syntax tree to store an abstract representation of the input.
This may be usefull when several passes are necessary.</p>
<p>This example shows how to parse an expression (infix, prefix or postfix) and convert it in infix,
prefix and postfix notation. The expression is saved in a tree. Each node of the tree correspond
to an operator in the expression. Each leaf is a number. Then to write the expression in infix,
prefix or postfix notation, we just need to walk throught the tree in a particular order.</p>
</div>
<div class="section" id="id13">
<h3>Abstract syntax trees</h3>
<p>The AST of this converter has three types of node:</p>
<dl class="docutils">
<dt>class Op</dt>
<dd>is used to store operators (<tt class="docutils literal">+</tt>, <tt class="docutils literal">-</tt>, <tt class="docutils literal">*</tt>, <tt class="docutils literal">/</tt>, <tt class="docutils literal">^</tt>).
It has two sons associated to the sub expressions.</dd>
<dt>class Atom</dt>
<dd>is an atomic expression (a number or a symbolic name).</dd>
<dt>class Func</dt>
<dd>is used to store functions.</dd>
</dl>
<p>These classes are instanciated by the init method. The infix, prefix and postfix methods
return strings containing the representation of the node in infix, prefix and postfix notation.</p>
</div>
<div class="section" id="grammar">
<h3>Grammar</h3>
<div class="section" id="lexical-definitions">
<h4>Lexical definitions</h4>
<pre class="literal-block">
ident = r'\b(?!sin|cos|tan|min|max)\w+\b' : `Atom` ;

func1 = r'sin' | r'cos' | r'tan' ;
func2 = r'min' | r'max' ;

op = op_add | op_mul | op_pow ;
op_add = r'[+-]' ;
op_mul = r'[*/]' ;
op_pow = r'\^' ;
</pre>
</div>
<div class="section" id="infix-expressions">
<h4>Infix expressions</h4>
<p>The grammar for infix expressions is similar to the grammar used in the previous example:</p>
<pre class="literal-block">
expr = term (op_add term :: `lambda op, y: lambda x: Op(op, x, y)`)* :: `red` ;
term = fact (op_mul fact :: `lambda op, y: lambda x: Op(op, x, y)`)* :: `red` ;
fact = atom (op_pow fact :: `lambda op, y: lambda x: Op(op, x, y)`)? :: `red` ;
atom = ident ;
atom = '(' expr ')' ;
atom = func1 '(' expr ')' :: `Func` ;
atom = func2 '(' expr ',' expr ')' :: `Func` ;
</pre>
<p><tt class="docutils literal">red</tt> is a function that applies a list of functions to a value:</p>
<pre class="literal-block">
def red(x, fs):
    for f in fs:
        x = f(x)
    return x
</pre>
</div>
<div class="section" id="prefix-expressions">
<h4>Prefix expressions</h4>
<p>The grammar for prefix expressions is very simple. A compound prefix expression is an operator
followed by two subexpressions, or a binary function followed by two subexpressions, or a unary
function followed by one subexpression:</p>
<pre class="literal-block">
expr_pre = ident ;
expr_pre = op expr_pre expr_pre :: `Op` ;
expr_pre = func1 expr_pre :: `Func` ;
expr_pre = func2 expr_pre expr_pre :: `Func` ;
</pre>
</div>
<div class="section" id="postfix-expressions">
<h4>Postfix expressions</h4>
<p>At first sight postfix and infix grammars may be very similar. Only the position of the operators
changes. So a compound postfix expression is a first expression followed by a second one and an
operator. This rule is left recursive. As SP is a descendant recursive parser, such rules are
forbidden to avoid infinite recursion. To remove the left recursion a classical solution is to
rewrite the grammar like this:</p>
<pre class="literal-block">
expr_post = ident expr_post_rest :: `lambda x, f: f(x)` ;
expr_post_rest =
    (   expr_post op    :: `lambda y, op: lambda x: Op(op, x, y)`
    |   expr_post func2 :: `lambda y, f: lambda x: Func(f, x, y)`
    |   func1           : `lambda f: lambda x: Func(f, x)`
    )   expr_post_rest  :: `lambda f, g: lambda x: g(f(x))` ;
expr_post_rest = `lambda x: x` ;
</pre>
<p>The parser searches for an atomic expression and builds the AST corresponding to the remaining
subexpression. <tt class="docutils literal">expr_post_rest</tt> returns a function that builds the complete AST when applied
to the first atomic expression. This is a way to simulate inherited attributes.</p>
<p>Using the previous <tt class="docutils literal">red</tt> function and the repetitions, this rule can be rewritten as:</p>
<pre class="literal-block">
expr_post = ident expr_post_rest* :: `red` ;
expr_post_rest =
    (   expr_post op    :: `lambda y, op: lambda x: Op(op, x, y)`
    |   expr_post func2 :: `lambda y, f: lambda x: Func(f, x, y)`
    |   func1           : `lambda f: lambda x: Func(f, x)`
    ) ;
</pre>
<p>or simply:</p>
<pre class="literal-block">
expr_post = ident
    (   expr_post op    :: `lambda y, op: lambda x: Op(op, x, y)`
    |   expr_post func2 :: `lambda y, f: lambda x: Func(f, x, y)`
    |   func1           : `lambda f: lambda x: Func(f, x)`
    )* :: `red` ;
</pre>
</div>
</div>
<div class="section" id="source-code">
<h3>Source code</h3>
<p>Here is the complete source code (notation.py):</p>
<pre class="literal-block">
#!/usr/bin/env python
#coding: UTF-8

# Simple Parser
# Copyright (C) 2009-2010 Christophe Delord
# http://www.cdsoft.fr/sp

# This file is part of Simple Parser.
# 
# Simple Parser is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Simple Parser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with Simple Parser.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

# Infix/prefix/postfix expression conversion

import sp

try:
    import readline
except ImportError:
    pass

class Op:
    &quot;&quot;&quot; Binary operator &quot;&quot;&quot;
    precedence = {'+':1, '-':1, '*':2, '/':2, '^':3}
    def __init__(self, op, a, b):
        self.op = op                    # operator (&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;^&quot;)
        self.prec = Op.precedence[op]   # precedence of the operator
        self.a, self.b = a, b           # operands
    def infix(self):
        a = self.a.infix()
        if self.a.prec &lt; self.prec: a = &quot;(%s)&quot;%a
        b = self.b.infix()
        if self.b.prec &lt;= self.prec: b = &quot;(%s)&quot;%b
        return &quot;%s %s %s&quot;%(a, self.op, b)
    def prefix(self):
        a = self.a.prefix()
        b = self.b.prefix()
        return &quot;%s %s %s&quot;%(self.op, a, b)
    def postfix(self):
        a = self.a.postfix()
        b = self.b.postfix()
        return &quot;%s %s %s&quot;%(a, b, self.op)

class Atom:
    &quot;&quot;&quot; Atomic expression &quot;&quot;&quot;
    def __init__(self, s):
        self.a = s
        self.prec = 99
    def infix(self): return self.a
    def prefix(self): return self.a
    def postfix(self): return self.a

class Func:
    &quot;&quot;&quot; Function expression &quot;&quot;&quot;
    def __init__(self, name, *args):
        self.name = name
        self.args = args
        self.prec = 99
    def infix(self):
        args = [a.infix() for a in self.args]
        return &quot;%s(%s)&quot;%(self.name, &quot;,&quot;.join(args))
    def prefix(self):
        args = [a.prefix() for a in self.args]
        return &quot;%s %s&quot;%(self.name, &quot; &quot;.join(args))
    def postfix(self):
        args = [a.postfix() for a in self.args]
        return &quot;%s %s&quot;%(&quot; &quot;.join(args), self.name)

# Grammar for arithmetic expressions

def red(x, fs):
    for f in fs:
        x = f(x)
    return x

parser = sp.compile(r&quot;&quot;&quot;

    ident = ident.r'\b(?!sin|cos|tan|min|max)\w+\b' : `Atom` ;

    func1 = r'sin' | r'cos' | r'tan' ;
    func2 = r'min' | r'max' ;

    op = op_add | op_mul | op_pow ;
    op_add = r'[+-]' ;
    op_mul = r'[*/]' ;
    op_pow = r'\^' ;

    separator: r'\s+' ;

    !axiom = expr      `&quot;infix&quot;`
           | expr_pre  `&quot;prefix&quot;`
           | expr_post `&quot;postfix&quot;`
           ;

    # Infix expressions

    expr = term (op_add term :: `lambda op, y: lambda x: Op(op, x, y)`)* :: `red` ;
    term = fact (op_mul fact :: `lambda op, y: lambda x: Op(op, x, y)`)* :: `red` ;
    fact = atom (op_pow fact :: `lambda op, y: lambda x: Op(op, x, y)`)? :: `red` ;
    atom = ident ;
    atom = '(' expr ')' ;
    atom = func1 '(' expr ')' :: `Func` ;
    atom = func2 '(' expr ',' expr ')' :: `Func` ;

    # Prefix expressions

    expr_pre = ident ;
    expr_pre = op expr_pre expr_pre :: `Op` ;
    expr_pre = func1 expr_pre :: `Func` ;
    expr_pre = func2 expr_pre expr_pre :: `Func` ;

    # Postfix expressions

    expr_post = ident
        (   expr_post op    :: `lambda y, op: lambda x: Op(op, x, y)`
        |   expr_post func2 :: `lambda y, f: lambda x: Func(f, x, y)`
        |   func1           : `lambda f: lambda x: Func(f, x)`
        )* :: `red` ;

&quot;&quot;&quot;)

try: raw_input
except NameError: raw_input = input

while 1:
    e = raw_input(&quot;:&quot;)
    if e == &quot;&quot;: break
    try:
        expr, t = parser(e)
    except Exception as e:
        print(e)
    else:
        print(&quot;« %s » is a %s expression&quot;%(e, t))
        print(&quot;\tinfix   : %s&quot;%expr.infix())
        print(&quot;\tprefix  : %s&quot;%expr.prefix())
        print(&quot;\tpostfix : %s&quot;%expr.postfix())

</pre>
</div>
</div>
<div class="section" id="complete-interactive-calculator">
<h2><a class="toc-backref" href="#id31">5.3&nbsp;&nbsp;&nbsp;Complete interactive calculator</a></h2>
<p>This chapter presents an extention of the calculator described in the <a class="reference internal" href="#tutorial">tutorial</a>.
This calculator has a memory.</p>
<p>The grammar has been rewritten using the SP language.</p>
<div class="section" id="new-functions">
<h3>New functions</h3>
<p>The calculator has memories.
A memory cell is identified by a name.
For example, if the user types <tt class="docutils literal">pi = 3.14</tt>,
the memory cell named <tt class="docutils literal">pi</tt> will contain the value of <tt class="docutils literal">pi</tt>
and <tt class="docutils literal">2*pi</tt> will return <tt class="docutils literal">6.28</tt>.</p>
</div>
<div class="section" id="id14">
<h3>Source code</h3>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Another calculator is available as a separate package.
<a class="reference external" href="http://www.cdsoft.fr/calc.html">Calc</a> is a full featured programmers' calculator.
It is scriptable and allows user functions.</p>
</div>
<p>Here is the complete source code (calc.py):</p>
<pre class="literal-block">
#!/usr/bin/env python

# Simple Parser
# Copyright (C) 2009-2010 Christophe Delord
# http://www.cdsoft.fr/sp

# This file is part of Simple Parser.
# 
# Simple Parser is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Simple Parser is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with Simple Parser.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

from __future__ import division

import math
import sys
import sp

try:
    import readline
except ImportError:
    pass

class Calc(dict):

    def __init__(self):
        dict.__init__(self)
        _fy = lambda f, y: lambda x: f(x, y)
        _fg = lambda f, g: lambda x: g(f(x))
        _ = lambda x: x
        fx = lambda f, x: f(x)
        xf = lambda x, f: f(x)
        def reduce(x, fs):
            for f in fs: x = f(x)
            return x
        self.parser = sp.compile(r&quot;&quot;&quot;

            ident = r'[a-zA-Z_]\w*' ;

            real = r'(?:\d+\.\d*|\d*\.\d+)(?:[eE][-+]?\d+)?|\d+[eE][-+]?\d+' : `float` ;
            int = r'\d+' : `int` ;
            var = ident : `self.__getitem__`;

            add_op = '+'    `lambda x, y: x + y` ;
            add_op = '-'    `lambda x, y: x - y` ;
            add_op = '|'    `lambda x, y: x | y` ;
            add_op = '^'    `lambda x, y: x ^ y` ;

            mul_op = '*'    `lambda x, y: x * y` ;
            mul_op = '/'    `lambda x, y: x / y` ;
            mul_op = '%'    `lambda x, y: x % y` ;
            mul_op = '&amp;'    `lambda x, y: x &amp; y` ;
            mul_op = '&gt;&gt;'   `lambda x, y: x &lt;&lt; y` ;
            mul_op = '&lt;&lt;'   `lambda x, y: x &gt;&gt; y` ;

            pow_op = '**'   `lambda x, y: x ** y` ;

            un_op = '+'     `lambda x: +x` ;
            un_op = '-'     `lambda x: -x` ;
            un_op = '~'     `lambda x: ~x` ;

            post_un_op = '!'    `math.factorial` ;

            separator: r'\s+';

            !S = ident '=' expr :: `self.__setitem__`
               | expr
               ;

            expr = term (add_op term :: `_fy`)* :: `reduce` ;
            term = fact (mul_op fact :: `_fy`)* :: `reduce` ;
            fact = un_op fact :: `fx` | pow ;
            pow = postfix (pow_op fact :: `_fy`)? :: `reduce` ;

            #postfix = atom post_un_op :: `xf` | atom ;
            postfix = atom _postfix :: `xf` ;
            _postfix = post_un_op _postfix :: `_fg` | `_` ;

            atom = '(' expr ')' ;
            atom = real | int ;
            atom = var ;

        &quot;&quot;&quot;)

    def __call__(self, input):
        return self.parser(input)

def exc():
    e = getattr(sys, 'exc_value', None)
    if e is None:
        info = getattr(sys, 'exc_info', None)
        if info is not None: e = info()[1]
    return e

try: raw_input
except NameError: raw_input = input

calc = Calc()

while True:
    expr = raw_input(&quot;: &quot;)
    sp.clean()
    try:
        val = calc(expr)
        if val is not None:
            print(&quot;= %s&quot;%calc(expr))
    except:
        print(&quot;! %s&quot;%exc())
    print(&quot;&quot;)

</pre>
</div>
</div>
</div>
</div>
</body>
</html>
